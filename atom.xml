<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一路追梦想</title>
  
  <subtitle>热爱技术，更热爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://picksomething.cn/"/>
  <updated>2018-05-08T08:20:18.927Z</updated>
  <id>http://picksomething.cn/</id>
  
  <author>
    <name>picksomething</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android多渠道批量打包，支持友盟和第三方加固</title>
    <link href="http://picksomething.cn/2018/05/08/Android%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%B9%E9%87%8F%E6%89%93%E5%8C%85%EF%BC%8C%E6%94%AF%E6%8C%81%E5%8F%8B%E7%9B%9F%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8A%A0%E5%9B%BA/"/>
    <id>http://picksomething.cn/2018/05/08/Android多渠道批量打包，支持友盟和第三方加固/</id>
    <published>2018-05-08T00:40:58.000Z</published>
    <updated>2018-05-08T08:20:18.927Z</updated>
    
    <content type="html"><![CDATA[<p>随着应用上线发布以及不断地迭代，Android平台现在发展到了要打20多个渠道包，打完还要使用第三方加固进行加固，所以每次版本一更新，重新打包加固都成了一个挺耗时的工作，个人也感觉这种重复性的工作挺浪费时间的，所以多渠道打包迫在眉睫。其实早在应用第一版上线的时候，自己就打算把多渠道打包这个功能搞一下，但因为公司现在就我一个移动端开发人员，平时事挺多的，加上一开始渠道包并不算多，所以就一直拖着，现在看到要打这么多渠道包，就想着先放下其他工作，优先把这个搞一下。</p><p>看完这篇文章你可以学到的内容大概有：</p><ul><li>如何查看是v1还是v2签名，以及如何进行v2签名</li><li>在v2签名的情况下，怎么通过不重复打包而批量生成多渠道包</li><li>如何实现友盟或者其他第三方统计的多渠道包</li><li>使用第三方加固怎么实现多渠道打包</li></ul><p>好了，现在开始进入正文：</p><h2 id="旧的多渠道打包技术"><a href="#旧的多渠道打包技术" class="headerlink" title="旧的多渠道打包技术"></a>旧的多渠道打包技术</h2><p>Android多渠道打包之前在开发其他应用的时候就已经搞过，那个时候主要用了三种方式来实现多渠道打包：</p><h3 id="通过gradle-flavor或者简单的重复脚本-已弃用"><a href="#通过gradle-flavor或者简单的重复脚本-已弃用" class="headerlink" title="通过gradle flavor或者简单的重复脚本(已弃用)"></a>通过gradle flavor或者简单的重复脚本(已弃用)</h3><p>这个相对简单，但是也因为没个渠道包都相当于要编译一遍，所以自然也耗费时间</p><h3 id="通过apktool反编译，然后替换渠道号"><a href="#通过apktool反编译，然后替换渠道号" class="headerlink" title="通过apktool反编译，然后替换渠道号"></a>通过apktool反编译，然后替换渠道号</h3><p>首先，我们先打出一个基准渠道包，然后通过apktool命令反编译基准包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool -f d app.apk</span><br></pre></td></tr></table></figure></p><p>接着在<code>AndroidManifest.xml</code>里面找出<code>&lt;meta-data&gt;</code>，根据特征找出你要修改的umeng或者是takingdata字段的渠道号，然后根据规则替换成你想打的渠道号，<br>替换完成之后通过apktool重新打包成apk文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool b app/</span><br></pre></td></tr></table></figure></p><p>最后重新签名就ok了，当然这些步骤都是通过脚本执行的，因为只需要打一个包，剩下的都是脚本来做反编译-替换渠道号-重新打包，所以速度比第一种是有质的提升。而且这种方式还可以解决有些特殊需求，比如有的接入的一些第三方的支付宝会把支付渠道放到<code>assets/config.properties</code>里面，这个时候通过修改一下脚本，<code>AndroidManifest.xml</code>和<code>config.properties</code>里面的都替换，能够很好地解决这种特殊情况，这种需求下第三种方法都是不能处理的</p><h3 id="解压apk修改，修改META-INF信息"><a href="#解压apk修改，修改META-INF信息" class="headerlink" title="解压apk修改，修改META-INF信息"></a>解压apk修改，修改META-INF信息</h3><p>再怎么说，上面那种还是需要反编译，重新编译，重新签名等。这相对来说是有点麻烦而且需要一点时间的，而且因为apktool版本的不同，会导致很多时候反编译失败，总之痛点也还是有的。这个时候自然而然就出现了解决这些痛点的第三种多渠道打包方式。因为实践发现：在apk解压之后的<code>META-INF</code>文件夹中，添加一个空白文件是不会破坏apk的签名的(现在的v2签名针对这种情况做出了调整)，所以可以直接在解压之后的<code>META-INF</code>里面来添加一个自定义的渠道文件，然后在代码中动态去获取添加的渠道号<br>因为这种方式不需要反编译-重新编译-重新签名，所以自然而然比第二种方式会快很多，不过这种对于友盟等等第三方统计的工具的话，就需要在代码中动态获取和注册渠道号了，而不能通过<code>AndroidManifest.xml</code>静态注册了</p><h2 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h2><p>随着Android各方面技术的不断发展，Google官方在Android7.0的时候推出了v2签名方案，关于v2签名不做重点讲解，贴两张官方的简介图，感兴趣的可以到官方查看<a href="https://source.android.com/security/apksigning/v2" target="_blank" rel="noopener">v2签名</a></p><p><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/201805/v2-desc.png"></p><p><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/201805/v2_protected.png"><br>从上图2我们可以看到，新的v2签名方案中<code>META-INF</code>属于保护区了，直接修改这个肯定是逃不过签名检查的，这样一来就直接导致了之前的最快速的方案3失效，当然了如果不想理会这个新签名v2，可以在gradle文件中的signingConfigs配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v2SigningEnabled false</span><br></pre></td></tr></table></figure></p><p>来继续使用旧的签名方式，如果你打算这样的话，那就不用继续看了，前面的3种方法都还是可行的。但是既然Google推出了v2签名，自然除了补安全漏洞外还是有其他优点的，慢慢地肯定都要普及的，这就好比之前Android 6.0推出权限动态申请一样，虽然当时很多应用还是继续用旧的方案，但是现在不一样慢慢都接收了</p><p>所以既然Google推出了v2签名，那我们就针对v2签名如何快速地实现多渠道打包来讲解，其实原理和之前旧的第三种模式是差不多的，我们从上面的图片中可以看到v2签名会验证区块1，3，4，那就只能从区块2下手了，根据Google官方对于v2的解释，v2区块除了签名信息内容外，安装的时候是不校验其他信息的，所以我们可以在2区块<code>APK signing block</code>部分写入渠道信息，而不影响apk包的签名校验算法的，具体原理大家可以参考美团的新一代的<a href="https://tech.meituan.com/android-apk-v2-signature-scheme.html" target="_blank" rel="noopener">打包工具Walle</a>，目前基于v2多渠道打包的原理和方案就美团的这个Walle和mcxiaoke大神的<a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="noopener">packer-ng-plugin</a></p><p>我用到的就是maxiaoke大神的packer-ng-plugin，maxiaoke大神做Android开发的应该都熟悉的吧，前几年Retrofit还没流行的时候，很多人应该都用过maxiaoke大神的镜像版的volley库了吧</p><p>开始介绍packer-ng-plugin的使用和遇到的一些问题：</p><h2 id="新一代多渠道打包工具packer-ng-plugin"><a href="#新一代多渠道打包工具packer-ng-plugin" class="headerlink" title="新一代多渠道打包工具packer-ng-plugin"></a>新一代多渠道打包工具packer-ng-plugin</h2><p>这个库的引入和基本配置就不用多说了吧，官方文档里面写的很清楚了，配置和基本使用中遇到什么问题多看几遍官方文档基本都能解决了，需要注意的一点就是在gradle中配置签名信息的时候：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        storeFile file(<span class="string">"keystore.jks"</span>)</span><br><span class="line">        storePassword <span class="string">"xxxxxxxx"</span></span><br><span class="line">        keyAlias <span class="string">"app"</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxxxx"</span></span><br><span class="line">        v2SigningEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加上<code>v2SigningEnabled true</code>来开启v2签名，要不然就没有必要了解基于v2签名的多渠道打包工具了<br>下面就介绍几个大家比较常用或者可能遇到的文档中没有具体说明的问题：<br><a id="more"></a></p><h3 id="使用umeng统计如何用packer-ng-plugin实现多渠道打包"><a href="#使用umeng统计如何用packer-ng-plugin实现多渠道打包" class="headerlink" title="使用umeng统计如何用packer-ng-plugin实现多渠道打包"></a>使用umeng统计如何用packer-ng-plugin实现多渠道打包</h3><p>因为<code>packer-ng-plugin</code>是讲渠道信息写入到<code>APK signing block</code>中的，那如果你是在<code>AndroidManifest</code>中配置umeng渠道号是无法实现多渠道打包的，所以解决办法就是动态配置umeng渠道号，首先<code>packer-ng-plugin</code>提供了获取渠道号的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String channel = PackerNg.getChannel(context);</span><br></pre></td></tr></table></figure></p><p>根据umeng官方动态设置渠道号的文档，我们只需要在App入口程序中加入如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String channel = PackerNg.getChannel(context);</span><br><span class="line">MobclickAgent.UMAnalyticsConfig config = <span class="keyword">new</span> MobclickAgent.UMAnalyticsConfig(</span><br><span class="line">        context, <span class="string">"umeng id"</span>, channel);</span><br><span class="line">MobclickAgent.startWithConfigure(config);</span><br></pre></td></tr></table></figure></p><p>需要注意一点的是，<code>packer-ng-plugin</code>上面写的如果没有找到渠道信息或者发生错误返回的””，事实上发生错误(v1签名，没有v2的签名区块)默认返回是<code>EMPTY_STRING</code>，但是如果是v2签名了，只是还没有写入渠道信息，这个时候返回的是<code>null</code>，亲测</p><h3 id="使用腾讯或者360加固之后怎么批量打渠道包"><a href="#使用腾讯或者360加固之后怎么批量打渠道包" class="headerlink" title="使用腾讯或者360加固之后怎么批量打渠道包"></a>使用腾讯或者360加固之后怎么批量打渠道包</h3><p>你可能想着简单点的方法大概是先每个渠道包使用<code>packer-ng-plugin</code>打好，然后再用加固工具一个个加固，事实证明这个是行不通的<br>首先，腾讯或者360加固之后如果使用他们的自动签名工具的话，默认都是v1签名，那这个时候你基于v2签名的工具去获取签名的时候自然会出现如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: No APK Signing Block before ZIP Central Directory</span><br></pre></td></tr></table></figure></p><p>也就是没有v2签名方案中的<code>APK Signing Block</code>，这样一来渠道信息自然也就没有了，所以你通过<code>packer</code>的<code>getChannel</code>获取的渠道信息都是””</p><p>那你肯定想着那我不用第三方加固的自动签名，加固成功后自己手动签名，首先加固成功之后手动签名也是要签v2签名，如何签v2签名呢?，</p><h4 id="引入另一个知识点，apksigner来进行v2签名："><a href="#引入另一个知识点，apksigner来进行v2签名：" class="headerlink" title="引入另一个知识点，apksigner来进行v2签名："></a>引入另一个知识点，apksigner来进行v2签名：</h4><p>这里就需要了解一下apksigner了，这个工具是Google官方在<code>build tool 24.0.3</code>以及更高版本中推出的，不要信网上一些认为v2签名是android 7引入的，所以apksigner工具也要在<code>build tool 25</code>以上的版本才有，并非如此，这个工具只是Google推出用来替代之前的<code>jarsigner</code>的，它即可以做v1签名，也可以做v2签名，默认是取决于你apk的<code>--min-sdk-version</code>和<code>--max-sdk-version</code>的，当然了你也可以通过参数<code>--v1-signing-enabled &lt;true | false&gt;</code>和<code>--v2-signing-enabled &lt;true | false&gt;</code>来去强制指定，具体apksigner的详细介绍大家可以去看官方文档了，建议大家把apksigner的路径添加到环境变量里面，这样每次使用的时候就不用切到对应的build tool目录里面了</p><p>关于apksigner的基础使用方法(更多用法看文档吧)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign  --ks keystore.jks  --ks-key-alias app  --ks-pass pass:xxxxxxxx  --key-pass pass:xxxxxxxx input.apk</span><br></pre></td></tr></table></figure></p><p>好了，继续回到刚才说加固之后的问题，你可能认为加固之后不自动签名，使用上面介绍的手动签v2签名就ok了。<strong>理论是这样的，然并卵，实际情况是apksigner直行v2签名之后，会把<code>APK Signing Block</code>里面的内容清除然后重新写入，那之前我们渠道号也是写入到这块里面，自然也被清除了</strong></p><p>所以，到底怎么办？答案很简单，加固之后用v2签名完成之后，再重新使用多渠道打包脚步再次写入一遍对应的渠道号，可以写入单个，可以写入多个，也可以按照文件列出的渠道列表写入，具体的<code>packer-ng-plugin</code>的文档中有介绍，总结一下就是，如果需要使用加固的话：</p><ul><li><p>先打一个基础包(前提是你按照文档完成了gradle的基本配置)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean apkRelease -Pchannels=init</span><br></pre></td></tr></table></figure><ul><li>然后将打出的基础包在第三方加固<br>加固完成之后使用签名脚本签v2签名，然后执行下面的命令开始批量在加固包的基础上生成渠道包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packer-ng generate --channels=ch1,ch2,ch3 --output=build/archives app.apk</span><br><span class="line">或者</span><br><span class="line">packer-ng generate --channels=@channels.txt --output=build/archives app.apk</span><br></pre></td></tr></table></figure></li></ul></li><li><p>完毕之后，你可以通过下面来验证所打的渠道包的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packer-ng verify app.apk</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File: app-test-360_sign_v2.apk</span><br><span class="line">Signed: true</span><br><span class="line">Channel: null</span><br></pre></td></tr></table></figure></li></ul><p><strong>最后需要注意的一点是：如果只用v2签名的包，安装到Android 7以下的设备上会提示<code>安装失败，找不到签名证书</code>，最好是使用v1 v2都签的方式。</strong><br>为了安全起见，你最后发包的时候可以使用apksigner验证一下签名信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner verify -v app-test-360_sign_v2.apk</span><br></pre></td></tr></table></figure></p><p>输出是下面这样就是v1,v2都签的，你就不用担心不兼容7.0以下的问题了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Verifies</span><br><span class="line">Verified using v1 scheme (JAR signing): true</span><br><span class="line">Verified using v2 scheme (APK Signature Scheme v2): true</span><br><span class="line">Number of signers: 1</span><br></pre></td></tr></table></figure></p><p>好了，大概就这些了，希望看完之后，你已经学会了开头的四个知识点</p><p><strong>参考文档：</strong></p><ul><li><a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="noopener">packer-ng-plugin</a></li><li><a href="https://source.android.com/security/apksigning/v2" target="_blank" rel="noopener">APK 签名方案 v2</a></li><li><a href="https://developer.android.com/studio/command-line/apksigner" target="_blank" rel="noopener">apksigner</a></li><li><a href="https://tech.meituan.com/android-apk-v2-signature-scheme.html" target="_blank" rel="noopener">新一代开源Android渠道包生成工具Walle</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着应用上线发布以及不断地迭代，Android平台现在发展到了要打20多个渠道包，打完还要使用第三方加固进行加固，所以每次版本一更新，重新打包加固都成了一个挺耗时的工作，个人也感觉这种重复性的工作挺浪费时间的，所以多渠道打包迫在眉睫。其实早在应用第一版上线的时候，自己就打算把多渠道打包这个功能搞一下，但因为公司现在就我一个移动端开发人员，平时事挺多的，加上一开始渠道包并不算多，所以就一直拖着，现在看到要打这么多渠道包，就想着先放下其他工作，优先把这个搞一下。&lt;/p&gt;
&lt;p&gt;看完这篇文章你可以学到的内容大概有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何查看是v1还是v2签名，以及如何进行v2签名&lt;/li&gt;
&lt;li&gt;在v2签名的情况下，怎么通过不重复打包而批量生成多渠道包&lt;/li&gt;
&lt;li&gt;如何实现友盟或者其他第三方统计的多渠道包&lt;/li&gt;
&lt;li&gt;使用第三方加固怎么实现多渠道打包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，现在开始进入正文：&lt;/p&gt;
&lt;h2 id=&quot;旧的多渠道打包技术&quot;&gt;&lt;a href=&quot;#旧的多渠道打包技术&quot; class=&quot;headerlink&quot; title=&quot;旧的多渠道打包技术&quot;&gt;&lt;/a&gt;旧的多渠道打包技术&lt;/h2&gt;&lt;p&gt;Android多渠道打包之前在开发其他应用的时候就已经搞过，那个时候主要用了三种方式来实现多渠道打包：&lt;/p&gt;
&lt;h3 id=&quot;通过gradle-flavor或者简单的重复脚本-已弃用&quot;&gt;&lt;a href=&quot;#通过gradle-flavor或者简单的重复脚本-已弃用&quot; class=&quot;headerlink&quot; title=&quot;通过gradle flavor或者简单的重复脚本(已弃用)&quot;&gt;&lt;/a&gt;通过gradle flavor或者简单的重复脚本(已弃用)&lt;/h3&gt;&lt;p&gt;这个相对简单，但是也因为没个渠道包都相当于要编译一遍，所以自然也耗费时间&lt;/p&gt;
&lt;h3 id=&quot;通过apktool反编译，然后替换渠道号&quot;&gt;&lt;a href=&quot;#通过apktool反编译，然后替换渠道号&quot; class=&quot;headerlink&quot; title=&quot;通过apktool反编译，然后替换渠道号&quot;&gt;&lt;/a&gt;通过apktool反编译，然后替换渠道号&lt;/h3&gt;&lt;p&gt;首先，我们先打出一个基准渠道包，然后通过apktool命令反编译基准包：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -jar apktool -f d app.apk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接着在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;里面找出&lt;code&gt;&amp;lt;meta-data&amp;gt;&lt;/code&gt;，根据特征找出你要修改的umeng或者是takingdata字段的渠道号，然后根据规则替换成你想打的渠道号，&lt;br&gt;替换完成之后通过apktool重新打包成apk文件：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -jar apktool b app/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后重新签名就ok了，当然这些步骤都是通过脚本执行的，因为只需要打一个包，剩下的都是脚本来做反编译-替换渠道号-重新打包，所以速度比第一种是有质的提升。而且这种方式还可以解决有些特殊需求，比如有的接入的一些第三方的支付宝会把支付渠道放到&lt;code&gt;assets/config.properties&lt;/code&gt;里面，这个时候通过修改一下脚本，&lt;code&gt;AndroidManifest.xml&lt;/code&gt;和&lt;code&gt;config.properties&lt;/code&gt;里面的都替换，能够很好地解决这种特殊情况，这种需求下第三种方法都是不能处理的&lt;/p&gt;
&lt;h3 id=&quot;解压apk修改，修改META-INF信息&quot;&gt;&lt;a href=&quot;#解压apk修改，修改META-INF信息&quot; class=&quot;headerlink&quot; title=&quot;解压apk修改，修改META-INF信息&quot;&gt;&lt;/a&gt;解压apk修改，修改META-INF信息&lt;/h3&gt;&lt;p&gt;再怎么说，上面那种还是需要反编译，重新编译，重新签名等。这相对来说是有点麻烦而且需要一点时间的，而且因为apktool版本的不同，会导致很多时候反编译失败，总之痛点也还是有的。这个时候自然而然就出现了解决这些痛点的第三种多渠道打包方式。因为实践发现：在apk解压之后的&lt;code&gt;META-INF&lt;/code&gt;文件夹中，添加一个空白文件是不会破坏apk的签名的(现在的v2签名针对这种情况做出了调整)，所以可以直接在解压之后的&lt;code&gt;META-INF&lt;/code&gt;里面来添加一个自定义的渠道文件，然后在代码中动态去获取添加的渠道号&lt;br&gt;因为这种方式不需要反编译-重新编译-重新签名，所以自然而然比第二种方式会快很多，不过这种对于友盟等等第三方统计的工具的话，就需要在代码中动态获取和注册渠道号了，而不能通过&lt;code&gt;AndroidManifest.xml&lt;/code&gt;静态注册了&lt;/p&gt;
&lt;h2 id=&quot;面临的问题&quot;&gt;&lt;a href=&quot;#面临的问题&quot; class=&quot;headerlink&quot; title=&quot;面临的问题&quot;&gt;&lt;/a&gt;面临的问题&lt;/h2&gt;&lt;p&gt;随着Android各方面技术的不断发展，Google官方在Android7.0的时候推出了v2签名方案，关于v2签名不做重点讲解，贴两张官方的简介图，感兴趣的可以到官方查看&lt;a href=&quot;https://source.android.com/security/apksigning/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v2签名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/201805/v2-desc.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/201805/v2_protected.png&quot;&gt;&lt;br&gt;从上图2我们可以看到，新的v2签名方案中&lt;code&gt;META-INF&lt;/code&gt;属于保护区了，直接修改这个肯定是逃不过签名检查的，这样一来就直接导致了之前的最快速的方案3失效，当然了如果不想理会这个新签名v2，可以在gradle文件中的signingConfigs配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;v2SigningEnabled false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来继续使用旧的签名方式，如果你打算这样的话，那就不用继续看了，前面的3种方法都还是可行的。但是既然Google推出了v2签名，自然除了补安全漏洞外还是有其他优点的，慢慢地肯定都要普及的，这就好比之前Android 6.0推出权限动态申请一样，虽然当时很多应用还是继续用旧的方案，但是现在不一样慢慢都接收了&lt;/p&gt;
&lt;p&gt;所以既然Google推出了v2签名，那我们就针对v2签名如何快速地实现多渠道打包来讲解，其实原理和之前旧的第三种模式是差不多的，我们从上面的图片中可以看到v2签名会验证区块1，3，4，那就只能从区块2下手了，根据Google官方对于v2的解释，v2区块除了签名信息内容外，安装的时候是不校验其他信息的，所以我们可以在2区块&lt;code&gt;APK signing block&lt;/code&gt;部分写入渠道信息，而不影响apk包的签名校验算法的，具体原理大家可以参考美团的新一代的&lt;a href=&quot;https://tech.meituan.com/android-apk-v2-signature-scheme.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;打包工具Walle&lt;/a&gt;，目前基于v2多渠道打包的原理和方案就美团的这个Walle和mcxiaoke大神的&lt;a href=&quot;https://github.com/mcxiaoke/packer-ng-plugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;packer-ng-plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我用到的就是maxiaoke大神的packer-ng-plugin，maxiaoke大神做Android开发的应该都熟悉的吧，前几年Retrofit还没流行的时候，很多人应该都用过maxiaoke大神的镜像版的volley库了吧&lt;/p&gt;
&lt;p&gt;开始介绍packer-ng-plugin的使用和遇到的一些问题：&lt;/p&gt;
&lt;h2 id=&quot;新一代多渠道打包工具packer-ng-plugin&quot;&gt;&lt;a href=&quot;#新一代多渠道打包工具packer-ng-plugin&quot; class=&quot;headerlink&quot; title=&quot;新一代多渠道打包工具packer-ng-plugin&quot;&gt;&lt;/a&gt;新一代多渠道打包工具packer-ng-plugin&lt;/h2&gt;&lt;p&gt;这个库的引入和基本配置就不用多说了吧，官方文档里面写的很清楚了，配置和基本使用中遇到什么问题多看几遍官方文档基本都能解决了，需要注意的一点就是在gradle中配置签名信息的时候：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;signingConfigs &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        storeFile file(&lt;span class=&quot;string&quot;&gt;&quot;keystore.jks&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        storePassword &lt;span class=&quot;string&quot;&gt;&quot;xxxxxxxx&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keyAlias &lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keyPassword &lt;span class=&quot;string&quot;&gt;&quot;xxxxxxxx&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        v2SigningEnabled &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;加上&lt;code&gt;v2SigningEnabled true&lt;/code&gt;来开启v2签名，要不然就没有必要了解基于v2签名的多渠道打包工具了&lt;br&gt;下面就介绍几个大家比较常用或者可能遇到的文档中没有具体说明的问题：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="http://picksomething.cn/tags/Gradle/"/>
    
      <category term="友盟" scheme="http://picksomething.cn/tags/%E5%8F%8B%E7%9B%9F/"/>
    
      <category term="加固" scheme="http://picksomething.cn/tags/%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative中ScrollView和弹出键盘的冲突</title>
    <link href="http://picksomething.cn/2018/04/26/ReactNative%E4%B8%ADScrollView%E5%92%8C%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%86%B2%E7%AA%81/"/>
    <id>http://picksomething.cn/2018/04/26/ReactNative中ScrollView和弹出键盘的冲突/</id>
    <published>2018-04-26T10:10:58.000Z</published>
    <updated>2018-05-08T00:43:21.170Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的React Native项目中有一个页面是外层ScrollView里面包含一个TextInput输入框，和一个提交按钮，大致结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextInput</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">TextInput</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CustomButton</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">CustomButton</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击输入框<code>TextInput</code>会弹出软键盘供用户输入内容，输入完成之后点击<code>CustomButton</code>会有后续的提交动作</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>功能实现很简单，提交测试之后发现被提了一个issue，内容是：</p><blockquote><p>每次输入完内容点击CustomButton提交的时候，都要点击两次才真正提交，点击CustomButton第一次只是会关闭软键盘，第二次才是真正的提交动作，希望能够改为点击一次就完成提交动作</p></blockquote><p>看到这个issue之后，赶紧安装测试了一下，发现真的是每次要提交的时候需要点击两次，一次关闭软键盘，一次提交动作，那既然真有问题，就要解决啊</p><p>根据之前多年开发Android的经验，我首先觉得是外层的ScrollView拦截了点击事件，如果软键盘在的话dismiss掉软键盘，同时消费掉了点击事件，不再向下传递。从而导致点击事件在软键盘出现的时候，无法到达CustomButton组件</p><p>根据猜想搜索了一下，发现确实有网友遇到这种情况，问题的原因也大致就是我上面的猜想，既然涉及到点击事件传递问题，那么通过组件重写点击事件获取过程中的onStartShouldSetResponderCapture回调是可以达到目的的，这种相对比较复杂，需要对React Native的事件获取-分发-消费有比较清晰和深入的了解，因为这里官方提供了更方便的解决方法，一般情况下就不会选择这种解法了，不过了解ReactNative的事件流程还是有必要的，改天我详细写写ReactNative的事件分化相关的内容</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>在ScrollView中添加如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keyboardShouldPersistTaps=&apos;handled&apos;</span><br><span class="line">或者</span><br><span class="line">keyboardShouldPersistTaps=&apos;always&apos;</span><br></pre></td></tr></table></figure></p><p>如果你的rn版本比较低，那么使用下面的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyboardShouldPersistTaps=&apos;true&apos;</span><br></pre></td></tr></table></figure></p><p>这些属性代表什么意思，官方文档说的很清楚，其实无非就是帮我们处理这个点击事件ScrollView拦截还是不拦截，是否允许子组件收到点击事件，文档解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keyboardShouldPersistTaps</span><br><span class="line">Determines when the keyboard should stay visible after a tap.</span><br><span class="line"></span><br><span class="line">&apos;never&apos;: (the default), tapping outside of the focused text input when the keyboard is up dismisses the keyboard. When this happens, children won&apos;t receive the tap.</span><br><span class="line">&apos;always&apos;: the keyboard will not dismiss automatically, and the scroll view will not catch taps, but children of the scroll view can catch taps.</span><br><span class="line">&apos;handled&apos;: the keyboard will not dismiss automatically when the tap was handled by a children, (or captured by an ancestor).</span><br><span class="line">false: deprecated, use &apos;never&apos; instead</span><br><span class="line">true: deprecated, use &apos;always&apos; instead</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写的React Native项目中有一个页面是外层ScrollView里面包含一个TextInput输入框，和一个提交按钮，大致结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="ReactNative" scheme="http://picksomething.cn/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://picksomething.cn/tags/ReactNative/"/>
    
      <category term="ScrollView" scheme="http://picksomething.cn/tags/ScrollView/"/>
    
      <category term="软键盘" scheme="http://picksomething.cn/tags/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>终于折腾好了</title>
    <link href="http://picksomething.cn/2018/04/24/%E7%BB%88%E4%BA%8E%E6%8A%98%E8%85%BE%E5%A5%BD%E4%BA%86/"/>
    <id>http://picksomething.cn/2018/04/24/终于折腾好了/</id>
    <published>2018-04-24T11:34:20.000Z</published>
    <updated>2018-04-24T14:14:00.621Z</updated>
    
    <content type="html"><![CDATA[<p>终于将博客换成hexo+github page了，真的是不折腾会死。。。<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/testimg.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于将博客换成hexo+github page了，真的是不折腾会死。。。&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/testimg.jpg&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Twitter" scheme="http://picksomething.cn/categories/Twitter/"/>
    
    
      <category term="博客" scheme="http://picksomething.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://picksomething.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS不显示LaunchScreen上的图片</title>
    <link href="http://picksomething.cn/2018/03/06/iOS%E4%B8%8D%E6%98%BE%E7%A4%BALaunchScreen%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87/"/>
    <id>http://picksomething.cn/2018/03/06/iOS不显示LaunchScreen上的图片/</id>
    <published>2018-03-06T03:38:27.000Z</published>
    <updated>2018-04-25T03:32:36.249Z</updated>
    
    <content type="html"><![CDATA[<p>因为并没有学习过iOS开发，现在用的react native开发的app，iOS和Android App上的启动屏都是原生代码实现的，现在新版启动屏ui图片有变化，然后技术主管又休假了，只能自己研究研究了。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>大概网上搜索学习了解了一下iOS的项目结构和程序入口，知道了LaunchScreen.storyboard是iOS的启动屏，AppDelegate是程序入口，于是就开始比着葫芦画瓢，将启动屏需要的图片资源添加到Images.scassets里面的splash文件夹里面，每个图片位置按照设计稿调整了一下，看效果图感觉差不多了，就开始跑一下试试，结果启动屏除了设置的背景颜色，上面的图片都没有显示。这就奇怪了，预览图上都有，怎么会不显示。。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>于是开始google，看来也有很多人遇到这种问题，有的说卸载重新安装就好了，试了没用；有的说把配置里面的Launch Screen File置空，试了还是没用；还有的说是因为Images.xcassets里面的图片应用启动的时候还没有以引用，把图片放到项目根目录就好了，我差点就信这个准备试试了，但是一想之前的图片都在这里面放着都是可以的，肯定不是这个问题，思来想去决定卸载重启试试，重启之后再安装启动，神奇般地显示启动屏上的图片了。。果然是重启大法好啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为并没有学习过iOS开发，现在用的react native开发的app，iOS和Android App上的启动屏都是原生代码实现的，现在新版启动屏ui图片有变化，然后技术主管又休假了，只能自己研究研究了。&lt;/p&gt;
&lt;h2 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问
      
    
    </summary>
    
      <category term="iOS" scheme="http://picksomething.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>JS基础之函数调用的困惑</title>
    <link href="http://picksomething.cn/2017/09/28/JS%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <id>http://picksomething.cn/2017/09/28/JS基础之函数调用的困惑/</id>
    <published>2017-09-28T07:07:21.000Z</published>
    <updated>2018-04-25T03:34:15.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>习惯了写java代码，然后开始学习js的时候，一开始总是会被js函数调用搞得有点晕乎，觉得有必要搞清楚js中函数调用不同的写法的一些含义和区别</p><h2 id="js中的函数"><a href="#js中的函数" class="headerlink" title="js中的函数"></a>js中的函数</h2><p>要搞清楚js中函数调用为什么会这样，首先需要明白js中的一个概念，那就是：函数是<code>JavaScript</code>中的「一等公民」<code>(Function is first-class citizen)</code>。<br>当你能够传递，返回和分配某个类型的时，那这个类型就被称为”一等公民”，js中的函数恰好就满足这些条件，所以js中的函数被称为是”一等公民”。<br>好了，不管js中函数是几等公民了，直接上代码来解决疑惑吧，假设我们页面中有一个按钮，点击的时候调用函数打印<code>Hello World</code>，函数代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来这段代码规规矩矩，没有什么问题，然后我们希望在一个组件被按压的时候调用这个函数，通常习惯了Java中函数调用的，可能顺手就是：<code>onPress = hello();</code>这对于习惯了java的人来说，可能觉得再普通不过了，但是对于js来说是有问题的。<br><a id="more"></a><br>如果我们希望组件在按压的时候输出这句话，很显然上面的调用方式是做不到的，因为上面这种写法，会在组件被渲染或者被加载的时候就会调用<code>hello</code>这个方法从而输出<code>Hello World</code>，也就是说如果带括号就表示该函数会被立即调用执行，并将返回值赋给<code>onPress</code>，而且当你再按压组件的时候也并不会再继续调用了(你可以试试)，这显然并不是你想要的结果，那么如何达到想要的结果呢？有两种办法：</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onPress = hello</span><br></pre></td></tr></table></figure><p>这看起来是将函数赋值给<code>onPress</code>啊，是的，确切地说js中函数也是对象，这里就是将改函数对象的引用或者说是入口地址赋值给<code>onPress</code>，然后在我们按压组件触发onPress动作的时候，就会真正地调用<code>hello</code>函数，打印出<code>Hello World</code>。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hi = funtion hello()&#123;</span><br><span class="line">  document.write(&apos;Hello World&apos;);</span><br><span class="line">&#125;</span><br><span class="line">onPress = hi;</span><br><span class="line">通过hi();这种也是相当于直接调用hello函数</span><br></pre></td></tr></table></figure><p>这样看起来可能更直观一些，也就是先将函数赋值给一个变量，然后把该变量(指向函数的一个引用变量)赋值给<code>onPress</code>函数，因为<code>onPress</code>也是一个普通的函数，可以给它赋一个值，也可以给它赋一个函数，所以如果直接是第一种做法的话，就相当于把<code>hello</code>函数的返回值(虽然这里并没有显式的返回值)赋值给<code>onPress</code>了，自然达不到你想要按压组件调用函数输出<code>Hello World</code>的效果了。</p><p>再延伸一点就到ES6引进的箭头函数了(这里就不多说了)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br><span class="line">onPress = hi;</span><br></pre></td></tr></table></figure></p><p>js还真是风骚啊。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;习惯了写java代码，然后开始学习js的时候，一开始总是会被js函数调用搞得有点晕乎，觉得有必要搞清楚js中函数调用不同的写法的一些含义和区别&lt;/p&gt;
&lt;h2 id=&quot;js中的函数&quot;&gt;&lt;a href=&quot;#js中的函数&quot; class=&quot;headerlink&quot; title=&quot;js中的函数&quot;&gt;&lt;/a&gt;js中的函数&lt;/h2&gt;&lt;p&gt;要搞清楚js中函数调用为什么会这样，首先需要明白js中的一个概念，那就是：函数是&lt;code&gt;JavaScript&lt;/code&gt;中的「一等公民」&lt;code&gt;(Function is first-class citizen)&lt;/code&gt;。&lt;br&gt;当你能够传递，返回和分配某个类型的时，那这个类型就被称为”一等公民”，js中的函数恰好就满足这些条件，所以js中的函数被称为是”一等公民”。&lt;br&gt;好了，不管js中函数是几等公民了，直接上代码来解决疑惑吧，假设我们页面中有一个按钮，点击的时候调用函数打印&lt;code&gt;Hello World&lt;/code&gt;，函数代码如下：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.write(&lt;span class=&quot;string&quot;&gt;&#39;Hello World&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看起来这段代码规规矩矩，没有什么问题，然后我们希望在一个组件被按压的时候调用这个函数，通常习惯了Java中函数调用的，可能顺手就是：&lt;code&gt;onPress = hello();&lt;/code&gt;这对于习惯了java的人来说，可能觉得再普通不过了，但是对于js来说是有问题的。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://picksomething.cn/categories/JavaScript/"/>
    
    
      <category term="funtion" scheme="http://picksomething.cn/tags/funtion/"/>
    
      <category term="js" scheme="http://picksomething.cn/tags/js/"/>
    
      <category term="对象" scheme="http://picksomething.cn/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>React Native基础之箭头函数</title>
    <link href="http://picksomething.cn/2017/09/26/React%20Native%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://picksomething.cn/2017/09/26/React Native基础之箭头函数/</id>
    <published>2017-09-26T04:39:19.000Z</published>
    <updated>2018-04-25T04:52:52.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道ES6允许使用“箭头”（=&gt;）定义函数，习惯Java中函数定义之后，刚开始接触js，每次看到箭头函数都感觉怪怪的，那么为什么ES6要引入箭头函数呢，这个问题也一直困扰这我，虽然只要明白了箭头函数的语法，基本就可以正常的学习rn，使用rn开始开发，但是有些东西搞不清楚，心里头就感觉不踏实，今天咨询了一下做前后端开发的大学室友，才稍微明白了一点</p><h2 id="引入箭头函数的原因"><a href="#引入箭头函数的原因" class="headerlink" title="引入箭头函数的原因"></a>引入箭头函数的原因</h2><ol><li>更简短的函数书写</li><li>对this的词法解析</li></ol><h3 id="更简短的函数书写"><a href="#更简短的函数书写" class="headerlink" title="更简短的函数书写"></a>更简短的函数书写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 箭头函数写法</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>上面的箭头函数的第二种写法里面的<code>x =&gt; x * x</code>是等价于<code>(x) =&gt; {return x * x}</code>,一个参数的时候小括号可以省略，后面的大括号如果省略的话，代表是一个隐式的返回值，具体这个箭头函数的语法可以看前一篇基础总结里面有提到</p><a id="more"></a><h3 id="对this的词法解析-不绑定自己的-this，arguments，super"><a href="#对this的词法解析-不绑定自己的-this，arguments，super" class="headerlink" title="对this的词法解析(不绑定自己的 this，arguments，super)"></a>对this的词法解析(不绑定自己的 this，arguments，super)</h3><p>这个相对于第一点，就不太好理解了，因为设计到this关键字，这个本身也是js语法的一个难点和痛点，js的this和java中的并不一样，所以对于初学者很容易被this搞的晕头转向，这里先不细说this，打算下一篇写写this关键字，先看测试代码吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onPressNormal&#125;</span><br><span class="line">        title=<span class="string">"调用普通函数"</span></span><br><span class="line">        color=<span class="string">"#841584"</span> /&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onPressArrow&#125;</span><br><span class="line">        title=<span class="string">"调用箭头函数"</span></span><br><span class="line">        color=<span class="string">"#841584"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">onPressNormal() &#123;</span></span><br><span class="line"><span class="regexp">  console.log('function normal :', this);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/console.log('function this state testFlag :', this.state.testFlag);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">onPressArrow = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log('function arrow:', this);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/console.log('function this state testFlag :', this.state.testFlag);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>在上面的两个方法中，你会发现打印输出的this对象并不一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactNativeJS: &apos;function normal :&apos;, &#123; accessibilityComponentType: &apos;button&apos;,</span><br><span class="line">ReactNativeJS: &apos;function arrow:&apos;, &#123; props: &#123; rootTag: 1 &#125;</span><br></pre></td></tr></table></figure></p><p>上面两个通过不同语法定义的方法，一个this对象指向的是button本身，一个指向的是该方法定义所在的全局对象，这样说可能并不直观，那我们进一步改一下上面两个方法输出，我在构造函数里面先定义一个state状态变量testFlag，默认值为false，然后在两个方法中分别输出该state变量:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onPressNormal() &#123;</span><br><span class="line">    <span class="comment">//console.log('function normal :', this);</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function this state testFlag :'</span>, <span class="keyword">this</span>.state.testFlag);</span><br><span class="line">&#125;</span><br><span class="line">onPressArrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//console.log('function arrow:', this);</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function this state testFlag :'</span>, <span class="keyword">this</span>.state.testFlag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你会发现箭头函数输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactNativeJS: &apos;function this state testFlag :&apos;, false</span><br></pre></td></tr></table></figure></p><p>但是普通定义的函数就直接error了，提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined is not an object(evaluting &apos;this.state.testFlag&apos;)</span><br></pre></td></tr></table></figure></p><p>同样的输出，只是不同的函数定义，在这种情况下差别就体现出来了，造成这的原因也就是函数里面的this指代的对象是不一样的，这也是引入箭头函数的第二个原因，<b>箭头函数会捕获其所在的上下文的this对象，作为自己的this值，从而确保代码运行结果和你期望的的结果一致</b>，当然你如果确实习惯了java这种方法定义，不喜欢用箭头函数，那么通过bind绑定this也是可以解决的</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这就是箭头函数带来的两个比较大的改变，但是使用箭头函数的时候也有几点需要注意的：</p><ul><li>this对象的指向是可变的，但是在箭头函数中，它是固定的，函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，不可以使用new命令</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们知道ES6允许使用“箭头”（=&amp;gt;）定义函数，习惯Java中函数定义之后，刚开始接触js，每次看到箭头函数都感觉怪怪的，那么为什么ES6要引入箭头函数呢，这个问题也一直困扰这我，虽然只要明白了箭头函数的语法，基本就可以正常的学习rn，使用rn开始开发，但是有些东西搞不清楚，心里头就感觉不踏实，今天咨询了一下做前后端开发的大学室友，才稍微明白了一点&lt;/p&gt;
&lt;h2 id=&quot;引入箭头函数的原因&quot;&gt;&lt;a href=&quot;#引入箭头函数的原因&quot; class=&quot;headerlink&quot; title=&quot;引入箭头函数的原因&quot;&gt;&lt;/a&gt;引入箭头函数的原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;更简短的函数书写&lt;/li&gt;
&lt;li&gt;对this的词法解析&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;更简短的函数书写&quot;&gt;&lt;a href=&quot;#更简短的函数书写&quot; class=&quot;headerlink&quot; title=&quot;更简短的函数书写&quot;&gt;&lt;/a&gt;更简短的函数书写&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 正常函数写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;].map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x * x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 箭头函数写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;].map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; x * x);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的箭头函数的第二种写法里面的&lt;code&gt;x =&amp;gt; x * x&lt;/code&gt;是等价于&lt;code&gt;(x) =&amp;gt; {return x * x}&lt;/code&gt;,一个参数的时候小括号可以省略，后面的大括号如果省略的话，代表是一个隐式的返回值，具体这个箭头函数的语法可以看前一篇基础总结里面有提到&lt;/p&gt;
    
    </summary>
    
      <category term="ReactNative" scheme="http://picksomething.cn/categories/ReactNative/"/>
    
    
      <category term="js" scheme="http://picksomething.cn/tags/js/"/>
    
      <category term="ReactNative" scheme="http://picksomething.cn/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>React Native基础之调用Android本地方法</title>
    <link href="http://picksomething.cn/2017/09/18/React%20Native%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B0%83%E7%94%A8Android%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://picksomething.cn/2017/09/18/React Native基础之调用Android本地方法/</id>
    <published>2017-09-18T11:04:06.000Z</published>
    <updated>2018-04-25T10:46:48.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习了一周React native之后，感觉还挺有意思的，今天来说说通过React native调用Android平台的一些本地方法(API)，以我目前的水平，感觉这个功能可能平时用的不会太多，但我感觉通过React native开发Android应用的过程中肯定会有用到的时候，本文以调用Android平台的Toast为例来讲讲如何通过React native调用Android<br>原生的一些方法(API)。</p><p>下面开始项目从创建到运行成功的全过程</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init CallNativeToast</span><br></pre></td></tr></table></figure><h2 id="创建一个NativeModule"><a href="#创建一个NativeModule" class="headerlink" title="创建一个NativeModule"></a>创建一个NativeModule</h2><p>本地模块一般是继承ReactContextBaseJavaModule的Java类，然后实现React native(js)调用Android本地API所需的功能，我们这次目标是通过js调用Android来展示一个Toast，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION_SHORT_KEY = <span class="string">"SHORT"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION_LONG_KEY = <span class="string">"LONG"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToastModule</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ToastExample"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; constants = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);</span><br><span class="line">        constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);</span><br><span class="line">        <span class="keyword">return</span> constants;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ReactMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String message, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getReactApplicationContext(), message, duration).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有几点需要说明："><a href="#有几点需要说明：" class="headerlink" title="有几点需要说明："></a>有几点需要说明：</h3><a id="more"></a><ul><li><p>getName返回的NativeModule名字，在后面JaveScript代码中是用来表示此类的，在js中我们可以通过NativeModule.ToastExample来访问此类</p></li><li><p>为了能够在js中调用Android的本地方法，需要被调用的方法必须加上<code>@ReactMethod</code>注释，作为js和java中的桥梁方法，该方法返回类型需要是void，访问权限为public</p></li><li><p>getConstants函数可实现，可不实现，主要是返回一些暴露给js的常量值，用于一些预定义的常量值，在js到java过程中的同步和一致。</p></li></ul><h2 id="注册模块"><a href="#注册模块" class="headerlink" title="注册模块"></a>注册模块</h2><p>接着就是在自定义的Package中注册上一步创建的NativeModule，如果不注册，上一步创建的NativeModule对于js是不可用的，也就是说如果想要在js中使用自己创建的NativeModule，必须要注册，注册是在createNativeModules方法中完成的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastReactPackage</span> <span class="keyword">implements</span> <span class="title">ReactPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NativeModule&gt; <span class="title">createNativeModules</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        List&lt;NativeModule&gt; modules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        modules.add(<span class="keyword">new</span> ToastModule(reactContext));</span><br><span class="line">        <span class="keyword">return</span> modules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册之后你需要在MainApplication(init创建项目的时候自动会生成此类)类中的getPackage方法中添加自定义的Package类的实例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> MainReactPackage(),</span><br><span class="line">            <span class="keyword">new</span> ToastReactPackage()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，在Java层(Android本地)的工作算是完成了，接着就是如何在js中调用了</p><h2 id="JS中调用"><a href="#JS中调用" class="headerlink" title="JS中调用"></a>JS中调用</h2><p>为了方便其他模块以后共用，或者说是为了项目结构清晰，我们把创建的NativeModule模块单独包装到一个js文件中，作为一个简单的库供其他文件引用，命名为ToastAndroid.js，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = NativeModules.ToastExample;</span><br></pre></td></tr></table></figure><p>那么我们就可以在另一个js文件中引入上面的文件，来调用上面的文件中所定义的展示toast的方法了，命名为TestToast.js，部分代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    StyleSheet,</span><br><span class="line">    View,</span><br><span class="line">    Button,</span><br><span class="line">    PixelRatio</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ToastExample <span class="keyword">from</span> <span class="string">'./ToastAndroid'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastTest</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Button style=&#123;styles.big_button&#125;</span><br><span class="line">                    title=<span class="string">"点击调用Android原生Toast"</span></span><br><span class="line">                    onPress=&#123;<span class="keyword">this</span>.onButtonClick&#125;</span><br><span class="line">                    accessibilityLabel=<span class="string">"展示一个Toast信息"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    onButtonClick(event) &#123;</span></span><br><span class="line"><span class="regexp">        ToastExample.show('Hello,原生Toast!', ToastExample.SHORT)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面就是一个简单的React native布局，一个按钮，点击的时候调用ToastExample模块中定义的show方法</p><p>最后为了能够展示该界面，我们在index.android.js中引用上述js文件并注册到项目，部分代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> ToastTest <span class="keyword">from</span> <span class="string">'./TestToast'</span></span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'CallNativeToast'</span>, () =&gt; ToastTest)</span><br></pre></td></tr></table></figure><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p>是时候放一张运行成功的图了</p><p><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2017/09/qq_pic_merged_1505732794971.jpg"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>React Native调用Android本地方法(API)到这就算是成功了，github完整代码：<a href="https://github.com/picksomething/CallNativeToast" target="_blank" rel="noopener">请戳这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习了一周React native之后，感觉还挺有意思的，今天来说说通过React native调用Android平台的一些本地方法(API)，以我目前的水平，感觉这个功能可能平时用的不会太多，但我感觉通过React native开发Android应用的过程中肯定会有用到的时候，本文以调用Android平台的Toast为例来讲讲如何通过React native调用Android&lt;br&gt;原生的一些方法(API)。&lt;/p&gt;
&lt;p&gt;下面开始项目从创建到运行成功的全过程&lt;/p&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;react-native init CallNativeToast&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;创建一个NativeModule&quot;&gt;&lt;a href=&quot;#创建一个NativeModule&quot; class=&quot;headerlink&quot; title=&quot;创建一个NativeModule&quot;&gt;&lt;/a&gt;创建一个NativeModule&lt;/h2&gt;&lt;p&gt;本地模块一般是继承ReactContextBaseJavaModule的Java类，然后实现React native(js)调用Android本地API所需的功能，我们这次目标是通过js调用Android来展示一个Toast，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ToastModule&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReactContextBaseJavaModule&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String DURATION_SHORT_KEY = &lt;span class=&quot;string&quot;&gt;&quot;SHORT&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String DURATION_LONG_KEY = &lt;span class=&quot;string&quot;&gt;&quot;LONG&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ToastModule&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ReactApplicationContext reactContext)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(reactContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;ToastExample&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; &lt;span class=&quot;title&quot;&gt;getConstants&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; constants = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; constants;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@ReactMethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String message, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; duration)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Toast.makeText(getReactApplicationContext(), message, duration).show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;有几点需要说明：&quot;&gt;&lt;a href=&quot;#有几点需要说明：&quot; class=&quot;headerlink&quot; title=&quot;有几点需要说明：&quot;&gt;&lt;/a&gt;有几点需要说明：&lt;/h3&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
      <category term="React Native" scheme="http://picksomething.cn/categories/Android/React-Native/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="ReactNative" scheme="http://picksomething.cn/tags/ReactNative/"/>
    
      <category term="JavaScript" scheme="http://picksomething.cn/tags/JavaScript/"/>
    
      <category term="NativeModule" scheme="http://picksomething.cn/tags/NativeModule/"/>
    
  </entry>
  
  <entry>
    <title>React Native基础之语法总结</title>
    <link href="http://picksomething.cn/2017/09/17/React%20Native%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://picksomething.cn/2017/09/17/React Native基础之语法总结/</id>
    <published>2017-09-16T16:01:20.000Z</published>
    <updated>2018-04-25T05:46:31.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近因为工作需要，开始学习React native，虽然以前学习过js，但都是上大学时候的事了，几年没关注这块了，现在又衍生出很多以js为基础的框架或者编程语言，习惯了Java，现在开始学习React native，最大的两点感觉：</p><ul><li>React native语法感觉好随意</li><li>代码看起来好乱啊</li></ul><p>不过既然要开始学习了React native了，就要搞清楚里面的方方面面。通过查看官方文档，Google搜索，大概整理了一些React native中容易忽略的基础东西(本文基于最新的ES6语法)</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量感觉React native和Java或者Python还是有挺多不一样的地方的，作为弱类型语言，React native里面竟然有三个定义变量的关键字：var,let和const<br><a id="more"></a></p><ul><li><p>var<br>这个学过js的应该都清楚，没记错的话js最早一直都是用这个来定义变量</p></li><li><p>let<br>之前学习swift的时候，好像swift语法里面也有let这个定义变量的关键字，在React native中，let和var的主要区别是作用域不同，var的作用域是函数内，也就是在一个函数内的任何地方都可以访问或者修改var定义的变量，而使用let定义的变量，只在定义该变量的代码区块内可用</p></li><li><p>const<br>这个和let的作用域相同，都在定义改变量的代码块内可用，它和let不同的是，const定义的变量是不可以改变的，类似java中带final的关键字变量，声明的时候需要赋值</p></li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ul><li><p>=&gt;(Arrow functions)<br>在看React native文档的时候，经常可以看到=&gt;这个符号，比如下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMoviesFromApiAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'https://facebook.github.io/react-native/movies.json'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">responseJson</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> responseJson.movies;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数getMoviesFromApiAsync函数里面，两次看到=&gt;这个符号，这个符号官方定义是叫做箭头函数(Arrow functions)，它语法简洁，和java 8中的lambda蛮像的，基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line">  <span class="comment">// equivalent to: (param1, param2, …, paramN) =&amp;gt; &#123; return expression; &#125;</span></span><br><span class="line">  <span class="comment">// Parentheses are optional when there's only one parameter name:</span></span><br><span class="line">  (singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">  singleParam =&gt; &#123; statements &#125;</span><br><span class="line">  <span class="comment">// A function with no parameters should be written with a pair of parentheses.</span></span><br><span class="line">  () =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>看完基本语法你就会明白上面的例子中<code>(response) =&gt; response.json</code>和<code>(responseJson) =&gt; {return responseJson.movies;}</code>的含义了：=&gt;前面小括号里面的相当于参数，=&gt;后面相当于函数返回值或者函数表达式</p><p>有几点需要注意的就是：</p><ul><li>如果没有参数需要传入，直接写()，切记不可省略</li><li>如果只有一个参数，()是可写可不写的</li><li>两个以上的参数，()是必须要写的</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在Java中假设你定义了一个String类型的变量<code>name=&quot;World&quot;</code>然后需要输出<code>Hello,World!</code>的时候，一般都是<code>printf(&quot;Hello,&quot; + name + &quot;!&quot;)</code>现在在React Native里面这种拼接也是允许的，但还有一种拼接方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Hello, $&#123;name&#125;!`</span><br></pre></td></tr></table></figure></p><p>这个和Android中字符串format是有点类似的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次就遇到了大概这些不明白的，然后学习总结了一下，后面遇到新的不明白的再继续总结，其实习惯了，感觉写React native也挺好的！<br>一个Hello World的React native项目：<a href="https://github.com/picksomething/ReactAndroidApp" target="_blank" rel="noopener">点击这里!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近因为工作需要，开始学习React native，虽然以前学习过js，但都是上大学时候的事了，几年没关注这块了，现在又衍生出很多以js为基础的框架或者编程语言，习惯了Java，现在开始学习React native，最大的两点感觉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React native语法感觉好随意&lt;/li&gt;
&lt;li&gt;代码看起来好乱啊&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过既然要开始学习了React native了，就要搞清楚里面的方方面面。通过查看官方文档，Google搜索，大概整理了一些React native中容易忽略的基础东西(本文基于最新的ES6语法)&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;变量感觉React native和Java或者Python还是有挺多不一样的地方的，作为弱类型语言，React native里面竟然有三个定义变量的关键字：var,let和const&lt;br&gt;
    
    </summary>
    
      <category term="ReactNative" scheme="http://picksomething.cn/categories/ReactNative/"/>
    
    
      <category term="js" scheme="http://picksomething.cn/tags/js/"/>
    
      <category term="ReactNative" scheme="http://picksomething.cn/tags/ReactNative/"/>
    
      <category term="const" scheme="http://picksomething.cn/tags/const/"/>
    
      <category term="function" scheme="http://picksomething.cn/tags/function/"/>
    
      <category term="let" scheme="http://picksomething.cn/tags/let/"/>
    
      <category term="语法" scheme="http://picksomething.cn/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android上传Library到JCenter可能遇到的问题</title>
    <link href="http://picksomething.cn/2017/03/29/Android%E4%B8%8A%E4%BC%A0Library%E5%88%B0JCenter%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://picksomething.cn/2017/03/29/Android上传Library到JCenter可能遇到的问题/</id>
    <published>2017-03-29T10:25:30.000Z</published>
    <updated>2018-04-25T08:02:22.238Z</updated>
    
    <content type="html"><![CDATA[<p>这并不是一篇教你如何step by step上传Android Library到JCenter，因为你随便搜一下，都会发现很多那样的文章，而且几乎都大同小异(互相抄)。正式因为抄来抄去，可能很多人并不会深究这个教程有什么问题，自己按照这个教程能够达到目的吗，可能会遇到了什么问题？本文的主要目的就是结合自己完成的过程告诉你按照网上的大部分教程你可能会遇到什么问题，当你因为参考网上大多数教程而又一直失败正在抓狂的时候，看看本文也许有帮助。</p><h2 id="问题一：在bintray-com上注册自己的账号"><a href="#问题一：在bintray-com上注册自己的账号" class="headerlink" title="问题一：在bintray.com上注册自己的账号"></a>问题一：在<code>bintray.com</code>上注册自己的账号</h2><p>大部分教程都是告诉你打开<code>https://bintray.com/</code>然后注册一个账号，然而随着bintray的更新，你现在打开该网站看到的是这样的(截止2017年03月29)：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2017/03/bintray.png"><br>你可能有点懵，为什么注册账号看起来还要钱，当你点击<strong>START YOUR FREE TRIAL</strong>去注册的时候，你其实已经进入了团队账号注册，类似于企业账号，所以你会发现会让你填写Company Name和Organization ID，除此之外和注册个人账号都一样了，如果你是这样注册的，等你按照网上大多数的教程step by step往下走的时候，你会发现到最后执行上传命令的时候，一直出现这样的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 401 Unauthorized [message:This resource requires authentication]</span><br></pre></td></tr></table></figure></p><p>按照网上的教程你以为是用户名或者apikey填错了，但是你会发现你怎么改都没用</p><p>正确的个人账号注册方法是点击<code>START YOUR FREE TRIAL</code>下方的<code>For Open Source Distribution Sign Up Here</code>来Sign Up，细心的你可能会发现，二者的注册地址是不一样的，企业的注册地址是<code>https://bintray.com/signup</code>，个人账号的注册地址是<code>https://bintray.com/signup/oss</code></p><p>这个坑浪费了我很多时间，当然也不是说如果按照企业账号注册最后就不能完成上传，一样可以，但是网上的教程几乎都是针对个人账号而言，如果你注册的是企业账号按照网上的教程是一定不能成功的，因为企业账号需要配置组织名称。</p><h2 id="问题二：artifactId要和Library-module的名字一样"><a href="#问题二：artifactId要和Library-module的名字一样" class="headerlink" title="问题二：artifactId要和Library module的名字一样"></a>问题二：<code>artifactId</code>要和<code>Library module</code>的名字一样</h2><p>当你到最后上传Library到JCenter的时候，你可能会遇到这样的错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request [</span><br><span class="line">message:Unable to upload files: Maven group, artifact or version defined <span class="keyword">in</span> the pom file <span class="keyword">do</span> not match the file path...]</span><br></pre></td></tr></table></figure></p><p>网上大多数可能会说是要artifactId要和libraryName保持一致，其实是artifactId要和你要上传的Library module的名字保持一致<br><a id="more"></a><br>这是我按照网上的大多数教程上传的时候遇到的两个比较坑的问题，其他如果还有什么问题，那应该就是个例了，google一下，应该都好解决。当然，针对网上大多数的教程，我还有一些建议：</p><blockquote><p>配置bintrayRepo的时候，并没有所谓的默认就是maven这一说，不要以为新建仓库的时候仓库类型选择是maven，默认名字就应该是maven，这个可以随便写，而且建议新建康库的时候最好不要叫maven，要么结合自己的用户名新建，要么结合功能用处新建，比如Android-xx等</p></blockquote><blockquote><p>配置bintrayName的时候，网上的教程基本上也是所谓的要和你在仓库里面新建的package保持一致，保持一致这句话没毛病，然而其实你没必要在仓库里面先新建一个package，只要你有仓库，其他信息都配置正确，上传的时候会自动按照你配置的<code>bintrayName</code>在你的仓库里面创建的</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>自己在github上放了上传到JCenter过程中简化gradle文件配置的模板文件，README里面也写清楚了如何使用，有需要的可以去参考一下：<a href="https://github.com/picksomething/jcenter-configuration" target="_blank" rel="noopener">github配置文件</a></p><p>同时自己也放上自己第一次上传的一个Library，需要的可以去查看：<a href="https://github.com/picksomething/sliding-tab-indicator" target="_blank" rel="noopener">slidingtabindicator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这并不是一篇教你如何step by step上传Android Library到JCenter，因为你随便搜一下，都会发现很多那样的文章，而且几乎都大同小异(互相抄)。正式因为抄来抄去，可能很多人并不会深究这个教程有什么问题，自己按照这个教程能够达到目的吗，可能会遇到了什么问题？本文的主要目的就是结合自己完成的过程告诉你按照网上的大部分教程你可能会遇到什么问题，当你因为参考网上大多数教程而又一直失败正在抓狂的时候，看看本文也许有帮助。&lt;/p&gt;
&lt;h2 id=&quot;问题一：在bintray-com上注册自己的账号&quot;&gt;&lt;a href=&quot;#问题一：在bintray-com上注册自己的账号&quot; class=&quot;headerlink&quot; title=&quot;问题一：在bintray.com上注册自己的账号&quot;&gt;&lt;/a&gt;问题一：在&lt;code&gt;bintray.com&lt;/code&gt;上注册自己的账号&lt;/h2&gt;&lt;p&gt;大部分教程都是告诉你打开&lt;code&gt;https://bintray.com/&lt;/code&gt;然后注册一个账号，然而随着bintray的更新，你现在打开该网站看到的是这样的(截止2017年03月29)：&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2017/03/bintray.png&quot;&gt;&lt;br&gt;你可能有点懵，为什么注册账号看起来还要钱，当你点击&lt;strong&gt;START YOUR FREE TRIAL&lt;/strong&gt;去注册的时候，你其实已经进入了团队账号注册，类似于企业账号，所以你会发现会让你填写Company Name和Organization ID，除此之外和注册个人账号都一样了，如果你是这样注册的，等你按照网上大多数的教程step by step往下走的时候，你会发现到最后执行上传命令的时候，一直出现这样的错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP/1.1 401 Unauthorized [message:This resource requires authentication]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;按照网上的教程你以为是用户名或者apikey填错了，但是你会发现你怎么改都没用&lt;/p&gt;
&lt;p&gt;正确的个人账号注册方法是点击&lt;code&gt;START YOUR FREE TRIAL&lt;/code&gt;下方的&lt;code&gt;For Open Source Distribution Sign Up Here&lt;/code&gt;来Sign Up，细心的你可能会发现，二者的注册地址是不一样的，企业的注册地址是&lt;code&gt;https://bintray.com/signup&lt;/code&gt;，个人账号的注册地址是&lt;code&gt;https://bintray.com/signup/oss&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个坑浪费了我很多时间，当然也不是说如果按照企业账号注册最后就不能完成上传，一样可以，但是网上的教程几乎都是针对个人账号而言，如果你注册的是企业账号按照网上的教程是一定不能成功的，因为企业账号需要配置组织名称。&lt;/p&gt;
&lt;h2 id=&quot;问题二：artifactId要和Library-module的名字一样&quot;&gt;&lt;a href=&quot;#问题二：artifactId要和Library-module的名字一样&quot; class=&quot;headerlink&quot; title=&quot;问题二：artifactId要和Library module的名字一样&quot;&gt;&lt;/a&gt;问题二：&lt;code&gt;artifactId&lt;/code&gt;要和&lt;code&gt;Library module&lt;/code&gt;的名字一样&lt;/h2&gt;&lt;p&gt;当你到最后上传Library到JCenter的时候，你可能会遇到这样的错误：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP/&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;400&lt;/span&gt; Bad Request [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;message:Unable to upload files: Maven group, artifact or version defined &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the pom file &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; not match the file path...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;网上大多数可能会说是要artifactId要和libraryName保持一致，其实是artifactId要和你要上传的Library module的名字保持一致&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="http://picksomething.cn/tags/Gradle/"/>
    
      <category term="JCenter" scheme="http://picksomething.cn/tags/JCenter/"/>
    
      <category term="Library" scheme="http://picksomething.cn/tags/Library/"/>
    
  </entry>
  
  <entry>
    <title>网络判断isConnected在网络正常的情况下依然返回false？</title>
    <link href="http://picksomething.cn/2017/02/21/%E7%BD%91%E7%BB%9C%E5%88%A4%E6%96%ADisConnected%E5%9C%A8%E7%BD%91%E7%BB%9C%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BE%9D%E7%84%B6%E8%BF%94%E5%9B%9Efalse%EF%BC%9F/"/>
    <id>http://picksomething.cn/2017/02/21/网络判断isConnected在网络正常的情况下依然返回false？/</id>
    <published>2017-02-21T07:11:14.000Z</published>
    <updated>2018-04-25T06:09:54.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近在测试一个功能的时候，偶然发现，网络连接都正常且能上网的情况下，居然提示网络不通，最开始以为只是偶然情况，就没太在意，后来发现能够重现，然后就决定研究一下，还真研究出一些问题</p><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><p>然后就看了一下程序判断网络是否连接的这一块代码，代码如下，很简单也很常规：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断网络是否连接</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNetworkConnected</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager)</span><br><span class="line">                context.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">        <span class="keyword">return</span> activeNetworkInfo != <span class="keyword">null</span> &amp;&amp; activeNetworkInfo.isConnected;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是普通的判断网络是否连接(注意，只是判断是否连接，至于能不能上网并不能判断)的，用的也都是Android自身的API来判断的，按说没有什么问题啊，但是就是这个方法一直返回false。。。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我首先想到可能的原因是权限问题，因为我用的是Android 6.0的测试机，Android 6.0之后很多权限不是需要程序主动去申请，用户同意之后才会获得，我就想着是不是因为没有获取到访问网络信息的权限，所以在获取网络连接情况的代码短的地方抛出异常了，导致返回的一直是false，带着疑问，我就调试了一下，发现程序并不会抛出异常，都是正常执行，networkInfo也不为null，networkInfo.isConnected返回的就是false，这下就有意思了，我看了一下NetworkInfo类的实例方法isConnected()，也没有被deprecated，也没有说可能会不准确之类的啊，就觉得更郁闷了。。。</p><p>然后我想看看其他手机是不是也是这样的，我试了一台Android4.3的vivo手机和一台同样系统版本的三星手机，都是正常的，然后又测试了一台Android 6.0的nexus手机，也是ok的，就唯独6.0的小米系统返回的是false。。。</p><p>为了更进一步确认是只有连接wifi的情况下会这样，还是说移动网络也会这样，我就把我的6.0的小米测试机的wifi关掉，用我的联通4G来测试，结果还是一样，isConnected依然返回false。</p><p>因为这个判断网络是否连接的方法，在应用打开的时候也会调用，我发现在应用打开的时候调用返回的就是true，都是正常的，唯独退出应用之后，后台定时任务每次调用的时候返回的就是false了，网上有说调用<code>isConnectedOrConnecting</code>，结果是一样的</p><p>总结一下就是，在6.0的小米手机上，正常在应用内调用isConnected()返回值都是正常的，等退出应用之后，通过定时任务调用就会在连接的情况下也返回false，其他测试手机则不会。</p><blockquote><p>于是我猜测：可能是miui为了流畅度或者是低耗电量等方面的优化，故意这样设计的，就是为了防止一些应用在后台定时判断网络连接的情况下，做一些网络请求任务，造成高耗电又影响流畅性，所以小米系统基本在所有应用都退出，回到桌面的情况下，有可能会短暂的禁掉当前的网络链接，当然这也只是猜测而已。</p></blockquote><h2 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h2><p>如果在小米6.0的机器上，大家非要在后台判断网络连接情况，那么目前来看，最保险的做法就是在程序中请求一下常用的网站，比如baidu，或者ping一下，来判断网络的真正链接情况，实现很简单，网上有很多，我在这里就不写了，当然我亲测这种方法是有效的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在测试一个功能的时候，偶然发现，网络连接都正常且能上网的情况下，居然提示网络不通，最开始以为只是偶然情况，就没太在意，后来发现能够重现，然后就决定研究一下，还真研究出一些问题&lt;/p&gt;
&lt;h2 id=&quot;查看代码&quot;&gt;&lt;a href=&quot;#查看代码&quot; class=&quot;headerlink&quot; title=&quot;查看代码&quot;&gt;&lt;/a&gt;查看代码&lt;/h2&gt;&lt;p&gt;然后就看了一下程序判断网络是否连接的这一块代码，代码如下，很简单也很常规：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * 判断网络是否连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;**/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isNetworkConnected&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConnectivityManager connectivityManager = (ConnectivityManager)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                context.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; activeNetworkInfo != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; activeNetworkInfo.isConnected;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这就是普通的判断网络是否连接(注意，只是判断是否连接，至于能不能上网并不能判断)的，用的也都是Android自身的API来判断的，按说没有什么问题啊，但是就是这个方法一直返回false。。。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="isConnected" scheme="http://picksomething.cn/tags/isConnected/"/>
    
      <category term="NetworkInfo" scheme="http://picksomething.cn/tags/NetworkInfo/"/>
    
      <category term="网络连接" scheme="http://picksomething.cn/tags/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义进度条时padding无效果?</title>
    <link href="http://picksomething.cn/2016/10/26/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%97%B6padding%E6%97%A0%E6%95%88%E6%9E%9C/"/>
    <id>http://picksomething.cn/2016/10/26/Android自定义进度条时padding无效果/</id>
    <published>2016-10-26T15:50:00.000Z</published>
    <updated>2018-04-25T07:15:29.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>标题很简单，自定义带padding的水平进度条，也就是如下效果的进度条：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/10/progressbar.png"></p><p>其实很简单，但是因为有一个坑还是要提出来，话不多说了，首先看看正常的实现：</p><h2 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案"></a>常规方案</h2><p>首先是布局文件中放一个ProgressBar控件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/custom_horizontal_progress"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"?android:attr/progressBarStyleHorizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:progressDrawable</span>=<span class="string">"@drawable/progress_bg_drawable"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>补充：为了更直观，我直接将16dp写到了布局文件中，规范写法这些值要放到dimen资源文件中引用<br><a id="more"></a></p><p>然后drawable目录下的progress_bg_drawable.xml文件是这样的：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/10/progress_bg_drawable.png"></p><p>绿色的进度条资源文件green_progress_drawable.xml是这样的：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/10/green_progress_drawable.png"></p><p>这个资源文件主要是对上面的绿色进度设置一些渐变色和圆角属性，如果没有渐变色，直接设置填充色<code>solid</code>属性即可。好了，到此自定义带padding的水平进度条基本工作就完成了，很简单，然后运行一看，效果也都和设计要求一样，似乎很顺利</p><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><blockquote><p>但是，你会发现在Android5.1以下的版本上，这样设置并不会有padding效果！！！</p></blockquote><p>为什么会这样，我还没搞明白，因为毕竟这不像是某个接口可以去看源码，看不同Android版本源码发生的改变，也没有Google出什么结果，如果有知道的还希望告知一下。那么如何解决Android 5.1以下的没有padding效果呢，继续往下看</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决办法就是修改上面的进度资源文件green_progress_drawable.xml，修改之后是这样的：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/10/new_green_progress_drawable.png"></p><p>修改的目的也就是在这里面设置padding，当然里面那个透明背景的第一个item是可要可不要的，重新在Android5.1以下的版本上运行，你会发现都带padding效果了，和设计的要求一样了</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>还没结束，如果你这样在Android 5.1以上的版本执行的时候你会发现原本你想要padding=2dp的效果， 确变成了padding=4的效果，原因是之前在progress_bg_drawable.xml文件中设置的padding在只在 Android5.1以上有效果，而在green_progress_drawable.xml里面设置的padding在各个Android版本上都有效果，所以记住把progress_bg_drawable.xml中设置的padding属性删除掉，防止在Android5.1以上的版本上重复设置</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;标题很简单，自定义带padding的水平进度条，也就是如下效果的进度条：&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/10/progressbar.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实很简单，但是因为有一个坑还是要提出来，话不多说了，首先看看正常的实现：&lt;/p&gt;
&lt;h2 id=&quot;常规方案&quot;&gt;&lt;a href=&quot;#常规方案&quot; class=&quot;headerlink&quot; title=&quot;常规方案&quot;&gt;&lt;/a&gt;常规方案&lt;/h2&gt;&lt;p&gt;首先是布局文件中放一个ProgressBar控件：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;ProgressBar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@+id/custom_horizontal_progress&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;?android:attr/progressBarStyleHorizontal&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;16dp&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:progressDrawable&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@drawable/progress_bg_drawable&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;补充：为了更直观，我直接将16dp写到了布局文件中，规范写法这些值要放到dimen资源文件中引用&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="progressbar" scheme="http://picksomething.cn/tags/progressbar/"/>
    
      <category term="padding" scheme="http://picksomething.cn/tags/padding/"/>
    
      <category term="progress" scheme="http://picksomething.cn/tags/progress/"/>
    
  </entry>
  
  <entry>
    <title>工作中常用的一些shell命令</title>
    <link href="http://picksomething.cn/2016/10/21/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9Bshell%E5%91%BD%E4%BB%A4/"/>
    <id>http://picksomething.cn/2016/10/21/工作中常用的一些shell命令/</id>
    <published>2016-10-21T04:31:13.000Z</published>
    <updated>2018-04-25T07:41:03.113Z</updated>
    
    <content type="html"><![CDATA[<p>开发人员掌握一些常用的命令，对于提高效率(B格)是很有帮助的，本篇文章记录下平时工作中常用的shell命令，同时也是为了测试一下新安装的markdown editor插件</p><h2 id="查看签名文件信息"><a href="#查看签名文件信息" class="headerlink" title="查看签名文件信息"></a>查看签名文件信息</h2><p>当我们想查看一个签名文件的md5等信息的时候，这个命令就很实用了，现在的一些应用市场认领应用啊，接入一些第三方的sdk啊，一般都需要apk的签名信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore debug.keystore</span><br></pre></td></tr></table></figure></p><h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><p>平时打完渠道包发给商务运营人员的时候，这个命令很常用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//压缩文件a.apk到a.zip中</span><br><span class="line">zip a.zip a.apk</span><br><span class="line"></span><br><span class="line">//压缩文件夹a到a.zip中</span><br><span class="line">zip -i a.zip a</span><br><span class="line"></span><br><span class="line">//加密压缩文件a.apk</span><br><span class="line">zip -e a.zip a.apk</span><br></pre></td></tr></table></figure><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//grep 查找某个字符串</span><br><span class="line">grep -rin baidu ./ 查找当前目录下所有包含baidu字段内容，并显示行号</span><br><span class="line">//grep 查找包含某个字符串的文件</span><br><span class="line">grep -rl baidu ./ 查找当前目录侠所有包含baidu的文件名</span><br><span class="line">-r 递归 -i 忽略大小写 -n显示行号(从1开始)</span><br><span class="line">-l --files-with-mathches -L --file-without-mathch</span><br></pre></td></tr></table></figure><p>比如当平时Android手机发生应用FC的时候，我们可以通过grep命令去在杂乱logcat找出crash信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抓取crash logcat信息(-A显示结果附近20行)</span><br><span class="line">adb logcat | grep -i "FATAL" -A 20</span><br><span class="line">-A num, --after-context=num 搜索内容后面显示多少行</span><br><span class="line">-B num, --before-content=num 搜索内容前面显示多少行</span><br></pre></td></tr></table></figure><h2 id="查看activity任务栈信息"><a href="#查看activity任务栈信息" class="headerlink" title="查看activity任务栈信息"></a>查看activity任务栈信息</h2><p>主要用于查看当前正在运行的任务栈信息，有助于分析activity的各种启动模式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep -i run</span><br></pre></td></tr></table></figure></p><h2 id="删除空文件"><a href="#删除空文件" class="headerlink" title="删除空文件"></a>删除空文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 0 -delete</span><br></pre></td></tr></table></figure><p>上面这些都是自己日常开发中经常用到的命令，熟练掌握这些命令是很有帮助的，如果想查看每个命令的更多用法可以使用<code>man xxx</code>去看官方用法说明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发人员掌握一些常用的命令，对于提高效率(B格)是很有帮助的，本篇文章记录下平时工作中常用的shell命令，同时也是为了测试一下新安装的markdown editor插件&lt;/p&gt;
&lt;h2 id=&quot;查看签名文件信息&quot;&gt;&lt;a href=&quot;#查看签名文件信息&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Shell" scheme="http://picksomething.cn/categories/Shell/"/>
    
    
      <category term="shell" scheme="http://picksomething.cn/tags/shell/"/>
    
      <category term="命令行" scheme="http://picksomething.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Android UI测试框架Espresso</title>
    <link href="http://picksomething.cn/2016/04/17/Android%20UI%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Espresso/"/>
    <id>http://picksomething.cn/2016/04/17/Android UI测试框架Espresso/</id>
    <published>2016-04-17T13:01:21.000Z</published>
    <updated>2018-04-25T15:12:14.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近这两周工作相对不那么忙了，所以就抽空结合官方文档研究了一下Android UI测试框架Espresso，从框架的setup到测试用例编写到执行测试用例</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Espresso是Google官方推出的开源UI测试框架，它的特点就是简洁，很容易上手编写测试用例，而且关于UI测试Espresso支持的也越来越完善了<br>官方项目地址：<a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="noopener">点击查看Espresso测试框架详细信息</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在dependencies里面添加引用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// App dependencies</span><br><span class="line">compile 'com.android.support:support-annotations:23.0.1'</span><br><span class="line">// Testing-only dependencies</span><br><span class="line">// Force usage of support annotations in the test app, since it is internally used by the runner module.</span><br><span class="line">androidTestCompile 'com.android.support:support-annotations:23.0.1'</span><br><span class="line">androidTestCompile 'com.android.support.test:runner:0.4.1'</span><br><span class="line">androidTestCompile 'com.android.support.test:rules:0.4.1'</span><br><span class="line">androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.1'</span><br></pre></td></tr></table></figure></p><p>在<code>android.defaultConfig</code>设置<code>instrumentation runner</code><br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"</span><br></pre></td></tr></table></figure></p><p>这里有一点需要注意的是官方文档中添加依赖的样例是这样的<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // App\'s dependencies, including test</span><br><span class="line">    compile 'com.android.support:support-annotations:22.2.0'</span><br><span class="line"></span><br><span class="line">    // Testing-only dependencies</span><br><span class="line">    androidTestCompile 'com.android.support.test:runner:0.5'</span><br><span class="line">    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果按照官方的这个来，build的时候你会遇到这样一个错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:Conflict with dependency 'com.android.support:support-annotations'</span><br></pre></td></tr></table></figure></p><ul><li><p>详情如下图所示：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/04/QQ20160417-0@2x.png"></p></li><li><p>产生这种错误的原因如下：<br>通常是因为你的主程序和测试程序使用了相同的库，但是使用的版本却不一样，你可能会觉得奇怪，看代码里面测试依赖并没有引用<code>support-annotations</code>库啊，为什么会说测试程序和主程序使用了相同的库，这是因为在测试库<code>runner</code>中内部使用了<code>support-annotations</code>库，而且我们知道在运行的时候主程序apk和测试apk是共享同一个进程和相同的class path，这就代表主程序和测试程序必须使用相同版本的任何依赖库，一旦版本不同，所以才会出现上面的冲突错误</p></li><li><p>形象说明见下图：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/04/QQ20160417-1@2x.png"></p></li><li><p>解决办法:<br>既然知道了问题产生的原因，那么解决办法也很简单，两种方法：</p></li></ul><ol><li>更改主程序里面对应冲突库的版本使其于测试程序里面的版本一致</li><li>更改测试程序里面冲突库的版本使其于主程序中的版本一致<br>通常比较简单的做法就是在build.gradle文件中显式加入另一个test dependencies和主程序代码中的冲突库版本一致的库，这样就强制要求测试程序也使用和主程序相同版本的库文件，像这样：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // App\'s dependencies, including test</span><br><span class="line">  compile '...:support-annotations:23.3.0'</span><br><span class="line"></span><br><span class="line">  // Testing-only dependencies</span><br><span class="line">  // Force the same version of support-annotations</span><br><span class="line">  compile '...:support-annotations:23.3.0'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><p>这个很简单，只要结合官方文档给出的例子，看看文档说明和对应的API，很容易上手，下面是我写的一个打开NavigationView的测试用例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openNavigationView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onView(withId(R.id.drawer_layout)).perform(</span><br><span class="line">        actionOpenNavigationView());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewAction <span class="title">actionOpenDrawer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewAction() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Matcher&lt;View&gt; <span class="title">getConstraints</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isAssignableFrom(DrawerLayout.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"open drawer"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(UiController uiController, View view)</span> </span>&#123;</span><br><span class="line">            ((DrawerLayout) view).openDrawer(GravityCompat.START);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释几个关键类：</p><h3 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h3><p>和视图views的交互切入点(通过onView和onData),而且也会暴露不需要依赖任何view的API(eg.pressBack)</p><h3 id="ViewMatchers"><a href="#ViewMatchers" class="headerlink" title="ViewMatchers"></a>ViewMatchers</h3><p>这个是我们如何find views的方式. ViewMatchers包含一个允许你在视图层次结构中找到指定的view的matchers的集合.以上，我们使用withId(R.id.etInput)来指明我们正在寻找的一个EditText，通过id = R.id.etInput</p><h2 id="ViewActions"><a href="#ViewActions" class="headerlink" title="ViewActions"></a>ViewActions</h2><p>这是我们如何和views交互，我们使用typeText(…)方法来在EditText写入hello</p><p>##ViewAssertions<br>这是我们的验证类. 我们使用ViewAssertions来验证views的指定属性. 大部分时候你将会使用由ViewMatchers下驱动的ViewAssertions. 在我们上面的例子中withText(…)方法实际上返回一个我们已经使用matchs(…)方法转换成一个ViewAssertion的ViewMatcher</p><blockquote><p>Espresso测试的标准模式是find a view(ViewMatchers), 在view上做一些事情(ViewActions), 然后验证view的一些属性(ViewAssertions).</p></blockquote><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onView(withId(R.id.my_view))      <span class="comment">// withId(R.id.my_view) is a ViewMatcher</span></span><br><span class="line">  .perform(click())               <span class="comment">// click() is a ViewAction</span></span><br><span class="line">  .check(matches(isDisplayed())); <span class="comment">// matches(isDisplayed()) is a ViewAssertion</span></span><br></pre></td></tr></table></figure></p><p>附上一张官网帮助记忆的小抄：</p><p><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/04/espresso-cheat-sheet-2.1.0.png"></p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>执行测试用例有两种方法：</p><ol><li>直接像运行app一样，通过Android Studio选择执行对应的测试程序</li><li>在项目根目录执行：./gradlew :testPreject:connectedAndroidTest</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://google.github.io/android-testing-support-library/" target="_blank" rel="noopener">https://google.github.io/android-testing-support-library/</a><br>2.<a href="https://guides.codepath.com/android/UI-Testing-with-Espresso" target="_blank" rel="noopener">https://guides.codepath.com/android/UI-Testing-with-Espresso</a><br>3.<a href="https://www.youtube.com/watch?v=OOEDKf06WqA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=OOEDKf06WqA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近这两周工作相对不那么忙了，所以就抽空结合官方文档研究了一下Android UI测试框架Espresso，从框架的setup到测试用例编写到执行测试用例&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Espresso是Google官方推出的开源UI测试框架，它的特点就是简洁，很容易上手编写测试用例，而且关于UI测试Espresso支持的也越来越完善了&lt;br&gt;官方项目地址：&lt;a href=&quot;https://google.github.io/android-testing-support-library/docs/espresso/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看Espresso测试框架详细信息&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;在dependencies里面添加引用&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// App dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compile &#39;com.android.support:support-annotations:23.0.1&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Testing-only dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Force usage of support annotations in the test app, since it is internally used by the runner module.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;androidTestCompile &#39;com.android.support:support-annotations:23.0.1&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;androidTestCompile &#39;com.android.support.test:runner:0.4.1&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;androidTestCompile &#39;com.android.support.test:rules:0.4.1&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;androidTestCompile &#39;com.android.support.test.espresso:espresso-core:2.2.1&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;android.defaultConfig&lt;/code&gt;设置&lt;code&gt;instrumentation runner&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="Espresso" scheme="http://picksomething.cn/tags/Espresso/"/>
    
      <category term="自动化测试" scheme="http://picksomething.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android getIdentifier用法</title>
    <link href="http://picksomething.cn/2016/03/31/Android%20getIdentifier%E7%94%A8%E6%B3%95/"/>
    <id>http://picksomething.cn/2016/03/31/Android getIdentifier用法/</id>
    <published>2016-03-31T14:18:55.000Z</published>
    <updated>2018-04-25T06:04:55.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近这段时间在忙着开发一个Android游戏，当然并不是真正的游戏，只是一个伪游戏而已，因为应用需要的图片资源和布局都比较多，所以难免就出现了下面这种类型的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (index) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        mView = mInflater.inflate(R.layout.layout_gift_one, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        mView = mInflater.inflate(R.layout.layout_gift_two, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        mView = mInflater.inflate(R.layout.layout_gift_three, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        mView = mInflater.inflate(R.layout.layout_gift_four, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        mView = mInflater.inflate(R.layout.layout_gift_five, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        mView = mInflater.inflate(R.layout.layout_gift_six, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于我这种有代码洁癖的人，每次看到这种代码我心里着实是不舒服的，今天上午写代码的时候，遇到一个这样的需求，简化一下大致是这样的：</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有6个textview用于显示6种商品的数量，然后定义了一个长度为6的数组用于存放6种商品的数量，那么有一个需求是要在特定的条件下将6种商品的数量置为0，同时在textview显示<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遇到这种问题，数组置0很简单，但是问题来了：6个textview都是从布局文件中获取的，每个textview的资源id不一样，每个textview的名字都不一样，相当于要执行6次<code>findviewById</code>和<code>xxxTextView.setText(&quot;0&quot;)</code>，我一想到这里，感觉如果这样写简直太丑陋了</p><p>心想既然标识商品的数量用的就是一个数组，那么可以不可以把6个textview也放到数组里面？正好这两天在stackoverflow上看另一个问题的时候，好像看到过类似的用法，模糊中记得好像是用的getIdentifier，于是就搜索了一下，果然可以，成功的将6个textview用一行代码就放到了一个长度为6的数组中，不用6次findViewById，也不用6次xxTextView.setText(“0”)了，一个循环就搞定了</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>学习要举一反三，学以致用，那么当我再次看到项目中开头那段代码的时候，心里想这个不是也可以使用getIdentifier简化吗，于是简化之后上面的代码就变成这样了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> layoutId = getResources().getIdentifier(</span><br><span class="line">        <span class="string">"layout_gift_"</span> + index, <span class="string">"layout"</span>, getPackageName());</span><br><span class="line">mView = mLayoutInflater.inflate(layoutId, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>是不是看起来整洁了很多</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>然后又点进去getIdentifier方法的源码里面看了一下，用法简介是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return a resource identifier for the given resource name.  A fully</span></span><br><span class="line"><span class="comment">  * qualified resource name is of the form "package:type/entry".  The</span></span><br><span class="line"><span class="comment">  * first two components (package and type) are optional if defType and</span></span><br><span class="line"><span class="comment">  * defPackage, respectively, are specified here.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdentifier</span><span class="params">(String name, String defType, String defPackage)</span></span></span><br></pre></td></tr></table></figure><p>也就是说传递参数的方式有两种情况：</p><ol><li><p>第一个参数按照<code>package:type/entry</code>的方式传递的话，那么后面两个type和package参数是可选的，也就是可以传null，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> layoutId = getResources().getIdentifier(</span><br><span class="line">    <span class="string">"com.huhulab.xxx:layout/layout_1"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>第一个参数的格式也就是：包名+”:”+资源属性类型+”/“+资源名，其中资源属性类型就是指你要获取的资源是layout，id或者drawable之类的</p></li><li><p>就是按照我上面的那种方法传递，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> textId = getResources().getIdentifier(</span><br><span class="line">    <span class="string">"text1"</span>,id,<span class="string">"com.huhulab.xxx"</span>);</span><br></pre></td></tr></table></figure><p>三个参数分别是：资源名，资源属性类型，包名</p></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>源码简介里面还有这么一句提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: use of this function is discouraged.  It is much more</span><br><span class="line">efficient to retrieve resources by identifier than by name.</span><br></pre></td></tr></table></figure></p><p>也就是说并不鼓励使用这个方法，因为通过id获取资源比通过名字获取资源更高效，也就是说这种方法耗时可能会比较久，所以除非必须不要过多使用这个方法<br>当然因为R.layout和R.id等其实都是一个内部类，你也可以通过反射获取类中的某一个变量，也就是你要找的那个资源名</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近这段时间在忙着开发一个Android游戏，当然并不是真正的游戏，只是一个伪游戏而已，因为应用需要的图片资源和布局都比较多，所以难免就出现了下面这种类型的代码片段：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (index) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mView = mInflater.inflate(R.layout.layout_gift_one, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mView = mInflater.inflate(R.layout.layout_gift_two, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mView = mInflater.inflate(R.layout.layout_gift_three, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mView = mInflater.inflate(R.layout.layout_gift_four, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mView = mInflater.inflate(R.layout.layout_gift_five, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mView = mInflater.inflate(R.layout.layout_gift_six, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于我这种有代码洁癖的人，每次看到这种代码我心里着实是不舒服的，今天上午写代码的时候，遇到一个这样的需求，简化一下大致是这样的：&lt;/p&gt;
&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;有6个textview用于显示6种商品的数量，然后定义了一个长度为6的数组用于存放6种商品的数量，那么有一个需求是要在特定的条件下将6种商品的数量置为0，同时在textview显示&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="identifier" scheme="http://picksomething.cn/tags/identifier/"/>
    
  </entry>
  
  <entry>
    <title>URLConnection.setDoOutput(true)导致Get请求变Post请求？</title>
    <link href="http://picksomething.cn/2016/02/18/URLConnection.setDoOutput(true)%E5%AF%BC%E8%87%B4Get%E8%AF%B7%E6%B1%82%E5%8F%98Post%E8%AF%B7%E6%B1%82%EF%BC%9F/"/>
    <id>http://picksomething.cn/2016/02/18/URLConnection.setDoOutput(true)导致Get请求变Post请求？/</id>
    <published>2016-02-18T15:38:49.000Z</published>
    <updated>2018-04-25T10:30:54.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写一个服务器下载图片并保存到SDcard上的基本功能的时候，部分代码自然而然地写成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(params[<span class="number">0</span>]);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">String path = BeautifyUtil.getDownloadsWallpaperPath();</span><br><span class="line">File file = <span class="keyword">new</span> File(path + <span class="string">"/"</span> + mWallpaperInfo.getFileName());</span><br><span class="line"></span><br><span class="line">FileOutputStream fileOutput = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">InputStream inputStream = connection.getInputStream();</span><br></pre></td></tr></table></figure></p><p>当时还特地看了一下<code>setDoOutput()</code>方法的源码说明<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets the flag indicating whether this &#123;<span class="doctag">@code</span> URLConnection&#125; allows</span></span><br><span class="line"><span class="comment">  * output. It cannot be set after the connection is established.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">  *            the new value for the flag to be set.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalAccessError</span></span><br><span class="line"><span class="comment">  *             if this method attempts to change the value after the</span></span><br><span class="line"><span class="comment">  *             connection has been already established.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #doOutput</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></p><p>我需要将图片流写入到SDcard上，所以设置setDoOutput(true)再合理不过了。。</p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>然而运行却一直报<code>java.io.FileNotFoundException</code>这样的错误，好奇服务器怎么会返回<code>404 Not Found</code>呢，特定打开图片的连接，看看服务器确实有对应的图片啊，百思不得其解只能Google了，偶然撇到搜索结果有说将<code>setDoOutput()</code>方法的参数改为<code>false</code>就行了，我抱着不解的态度试试，居然真好了。</p><h2 id="寻找原因"><a href="#寻找原因" class="headerlink" title="寻找原因"></a>寻找原因</h2><p>但是总不能到这就结束了啊，总要搞清楚为什么会这样啊，继续不懈的搜索，发现了这篇文章:<a href="http://webdiary.com/tag/httpurlconnection/" target="_blank" rel="noopener">Android 4.0 turns GET into POST</a></p><p>据说设置<code>setDoOutput(true)</code>之后，Android会认为这是一个POST请求，那么一旦服务器不支持POST请求，或者虽然支持，但是必须的参数你没有传过去，那么就会返回<code>404 NOT FOUND</code>，就有了上面的那个<code>FileNotFound</code>的异常了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://stackoverflow.com/questions/8587913/what-exactly-does-urlconnection-setdooutput-affect" target="_blank" rel="noopener">What exactly does URLConnection.setDoOutput() affect?</a></li><li><p><a href="http://comments.gmane.org/gmane.comp.handhelds.android.devel/195330" target="_blank" rel="noopener">Ice Cream Sandwich networking problems</a></p></li><li><p><a href="http://webdiary.com/tag/httpurlconnection/" target="_blank" rel="noopener">Android 4.0 turns GET into POST</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在写一个服务器下载图片并保存到SDcard上的基本功能的时候，部分代码自然而然地写成这样：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;URL url = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; URL(params[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HttpURLConnection connection = (HttpURLConnection) url.openConnection();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connection.setRequestMethod(&lt;span class=&quot;string&quot;&gt;&quot;GET&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connection.setDoOutput(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connection.connect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String path = BeautifyUtil.getDownloadsWallpaperPath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(path + &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt; + mWallpaperInfo.getFileName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FileOutputStream fileOutput = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;InputStream inputStream = connection.getInputStream();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当时还特地看了一下&lt;code&gt;setDoOutput()&lt;/code&gt;方法的源码说明&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="setDoOutput" scheme="http://picksomething.cn/tags/setDoOutput/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager+Fragment+自定义Tab的使用</title>
    <link href="http://picksomething.cn/2016/01/12/ViewPager+Fragment+%E8%87%AA%E5%AE%9A%E4%B9%89Tab%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://picksomething.cn/2016/01/12/ViewPager+Fragment+自定义Tab的使用/</id>
    <published>2016-01-12T06:19:15.000Z</published>
    <updated>2018-04-26T03:03:39.296Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Google在Android Design Supprot Library增加了很多Material Design控件，使我们能够更加轻松地开发出很多美观又灵活的UI。</p><p>其中新增的Tabs就是一个很实用的控件，我们可以使用Tabs+ViewPager+Fragment写出很多实用的控件，如图一所示，关于Tabs控件的更多信息，大家可以阅读官方文档：<a href="https://www.google.com/design/spec/components/tabs.html#" target="_blank" rel="noopener">点击这里</a><br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/01/components_tabs_usage_mobile4.png"></p><p>但是，有些时候我们的需求可能不是正好会和官方提供的控件相吻合，受限于这些官方Material Design控件都是遵循固定的设计标准，有些时候我们不得不自己重写控件，或者寻求其它实现方式，比如如图二所示的UI：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/01/QQ20160112-0.png"></p><p>因为官方的Tabs控件每个Tab是有最小宽度的(看源码好像是56dp)，也就是说无论你字体设置多小，每个Tab的最小宽度都不会变，而且图二在Tab的右边还要添加一些单个的控件，这个时候显然我们自己定义Tab布局，然后结合ViewPager和Fragment使用起来更方便，图二中的每个Tab项的宽度我们可以随便调，在右边可以随意添加单独控件<br><a id="more"></a><br>下面讲一下图二的实现过程，其实主要就是在上方加入一个Tab布局，然后通过给ViewPager设置OnPageChangeListener监听器来动态改变Tab下面的Indicator Line的leftMargin来实现滑动效果，全部源码链接在文章末尾，下面列出主要实现代码：</p><ul><li><p>首先是主界面上方的Tab布局<br>这个布局中主要就是上方的三个tab和最右边的一个imageView已经tab下方的indicatorLine，布局很简单，源代码就不再列出，感兴趣的可以参考文章最后的源码链接，不再赘述</p></li><li><p>FragmentPagerAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautifyFragmentAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List mFragments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeautifyFragmentAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">        mFragments.add(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Fragment用来展示数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautifyMainFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAGES_TYPE = <span class="string">"pages_type"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_WALLPAPER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_THEME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_FONT = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mPageType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mPageType = getArguments().getInt(PAGES_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.layout_beautify_fragment_list,</span><br><span class="line">             container, <span class="keyword">false</span>);</span><br><span class="line">        textView.setText(<span class="string">"第"</span> + mPageType + <span class="string">"页"</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为ViewPager设置Adapter，关键代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAdapter = <span class="keyword">new</span> BeautifyFragmentAdapter(getSupportFragmentManager());</span><br><span class="line"></span><br><span class="line">    Bundle wallpaperData = <span class="keyword">new</span> Bundle();</span><br><span class="line">    wallpaperData.putInt(BeautifyMainFragment.PAGES_TYPE,</span><br><span class="line">          BeautifyMainFragment.TYPE_WALLPAPER);</span><br><span class="line">    BeautifyMainFragment wallpaper = <span class="keyword">new</span> BeautifyMainFragment();</span><br><span class="line">    wallpaper.setArguments(wallpaperData);</span><br><span class="line">    mAdapter.addFragment(wallpaper);</span><br><span class="line"></span><br><span class="line">    Bundle themeData = <span class="keyword">new</span> Bundle();</span><br><span class="line">    themeData.putInt(BeautifyMainFragment.PAGES_TYPE,</span><br><span class="line">          BeautifyMainFragment.TYPE_THEME);</span><br><span class="line">    BeautifyMainFragment theme = <span class="keyword">new</span> BeautifyMainFragment();</span><br><span class="line">    theme.setArguments(themeData);</span><br><span class="line">    mAdapter.addFragment(theme);</span><br><span class="line"></span><br><span class="line">    Bundle fontData = <span class="keyword">new</span> Bundle();</span><br><span class="line">    fontData.putInt(BeautifyMainFragment.PAGES_TYPE,</span><br><span class="line">           BeautifyMainFragment.TYPE_FONT);</span><br><span class="line">    BeautifyMainFragment font = <span class="keyword">new</span> BeautifyMainFragment();</span><br><span class="line">    font.setArguments(fontData);</span><br><span class="line">    mAdapter.addFragment(font);</span><br><span class="line"></span><br><span class="line">    viewPager.setAdapter(mAdapter);</span><br><span class="line">    viewPager.setCurrentItem(<span class="number">0</span>);</span><br><span class="line">    viewPager.addOnPageChangeListener(onPageChangeListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里只使用了一个Fragment文件，然后通过添加不同的参数来区分属于不同的page，当然也可以使用三个不同的Fragment文件针对不同的Tab，看个人习惯了</p><ul><li>重写onPageScrolled方法实现indicatorLine的滑动<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">ViewPager.OnPageChangeListener onPageChangeListener = <span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * position:当前页面，以及你点击滑动的页面</span></span><br><span class="line"><span class="comment">      * offset:当前页面偏移的百分比</span></span><br><span class="line"><span class="comment">      * offsetPixels:当前页面偏移的像素位置</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> offset, <span class="keyword">int</span> offsetPixels)</span> </span>&#123;</span><br><span class="line">        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams)</span><br><span class="line">                indicatorLine.getLayoutParams();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 利用currentIndex(当前所在页面)和position以及offset来</span></span><br><span class="line"><span class="comment">          * 设置indicatorLine的左边距，这里有3个页面 滑动场景：</span></span><br><span class="line"><span class="comment">          * 从左到右分别为0,1,2</span></span><br><span class="line"><span class="comment">          * 0-&gt;1; 1-&gt;2; 2-&gt;1; 1-&gt;0</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentIndex == <span class="number">0</span> &amp;amp;&amp;amp; position == <span class="number">0</span>) &#123; <span class="comment">// 0-&gt;1</span></span><br><span class="line">            lp.leftMargin = (<span class="keyword">int</span>) (offset * tabWidthPx</span><br><span class="line">                  + currentIndex * tabWidthPx);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentIndex == <span class="number">1</span> &amp;amp;&amp;amp; position == <span class="number">0</span>) &#123; <span class="comment">// 1-&gt;0</span></span><br><span class="line">            lp.leftMargin = (<span class="keyword">int</span>) (-(<span class="number">1</span> - offset) * tabWidthPx</span><br><span class="line">                  + currentIndex * tabWidthPx);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentIndex == <span class="number">1</span> &amp;amp;&amp;amp; position == <span class="number">1</span>) &#123; <span class="comment">// 1-&gt;2</span></span><br><span class="line">            lp.leftMargin = (<span class="keyword">int</span>) (offset * tabWidthPx</span><br><span class="line">                  + currentIndex * tabWidthPx);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentIndex == <span class="number">2</span> &amp;amp;&amp;amp; position == <span class="number">1</span>) &#123; <span class="comment">// 2-&gt;1</span></span><br><span class="line">            lp.leftMargin = (<span class="keyword">int</span>) (-(<span class="number">1</span> - offset) * tabWidthPx</span><br><span class="line">                  + currentIndex * tabWidthPx);</span><br><span class="line">        &#125;</span><br><span class="line">        indicatorLine.setLayoutParams(lp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        resetTextView();</span><br><span class="line">        <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                wallpaperTitle.setTextColor(ContextCompat.getColor(</span><br><span class="line">                      BeautifyMainActivity.<span class="keyword">this</span>, R.color.bm_tab_text_selected));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                themeTitle.setTextColor(ContextCompat.getColor(</span><br><span class="line">                      BeautifyMainActivity.<span class="keyword">this</span>, R.color.bm_tab_text_selected));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                fontTitle.setTextColor(ContextCompat.getColor(</span><br><span class="line">                      BeautifyMainActivity.<span class="keyword">this</span>, R.color.bm_tab_text_selected));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentIndex = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * state:滑动中的状态 有三种状态（0，1，2） 0：什么都没做 1：正在滑动 2：滑动完毕</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 重置颜色</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetTextView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    wallpaperTitle.setTextColor(ContextCompat.getColor(</span><br><span class="line">        <span class="keyword">this</span>, R.color.bm_tab_text));</span><br><span class="line">    themeTitle.setTextColor(ContextCompat.getColor(</span><br><span class="line">        <span class="keyword">this</span>, R.color.bm_tab_text));</span><br><span class="line">    fontTitle.setTextColor(ContextCompat.getColor(</span><br><span class="line">        <span class="keyword">this</span>, R.color.bm_tab_text));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Ok，到这里自定义的Tab+ViewPager+Fragment基本就实现了<br>源码地址：<a href="https://github.com/picksomething/ViewPagerWithTab" target="_blank" rel="noopener">https://github.com/picksomething/ViewPagerWithTab</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Google在Android Design Supprot Library增加了很多Material Design控件，使我们能够更加轻松地开发出很多美观又灵活的UI。&lt;/p&gt;
&lt;p&gt;其中新增的Tabs就是一个很实用的控件，我们可以使用Tabs+ViewPager+Fragment写出很多实用的控件，如图一所示，关于Tabs控件的更多信息，大家可以阅读官方文档：&lt;a href=&quot;https://www.google.com/design/spec/components/tabs.html#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/01/components_tabs_usage_mobile4.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是，有些时候我们的需求可能不是正好会和官方提供的控件相吻合，受限于这些官方Material Design控件都是遵循固定的设计标准，有些时候我们不得不自己重写控件，或者寻求其它实现方式，比如如图二所示的UI：&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2016/01/QQ20160112-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为官方的Tabs控件每个Tab是有最小宽度的(看源码好像是56dp)，也就是说无论你字体设置多小，每个Tab的最小宽度都不会变，而且图二在Tab的右边还要添加一些单个的控件，这个时候显然我们自己定义Tab布局，然后结合ViewPager和Fragment使用起来更方便，图二中的每个Tab项的宽度我们可以随便调，在右边可以随意添加单独控件&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Fragment" scheme="http://picksomething.cn/tags/Fragment/"/>
    
      <category term="Tab" scheme="http://picksomething.cn/tags/Tab/"/>
    
      <category term="ViewPager" scheme="http://picksomething.cn/tags/ViewPager/"/>
    
  </entry>
  
  <entry>
    <title>生病这半月</title>
    <link href="http://picksomething.cn/2015/12/20/%E7%94%9F%E7%97%85%E8%BF%99%E5%8D%8A%E6%9C%88/"/>
    <id>http://picksomething.cn/2015/12/20/生病这半月/</id>
    <published>2015-12-20T11:06:28.000Z</published>
    <updated>2018-04-25T03:40:23.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>11月27号，周五，上班的时候感觉要有点感冒，心想昨夜打球可能着凉了，想着多喝点开水，也许就不会感冒了！</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>11月28号，周六，在家睡觉不想起，感觉浑身很冷，想着可能有点发烧，拿出体温计量了一下38度多，难受了一整天，到夜里都接近39度了，喝了点感冒退烧药就睡去了，心想明天还发烧一定要去看医生。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>11月29号，周日，依然发烧，并且开始咳嗽，因为四月份刚来杭州，这是来杭州第一次生病，也不知道附近哪里有看病的地方，想着一个感冒发烧也用不着去大医院吧，手机搜索了一下，附近不远有浙江大学紫金港校区医院，心想校医院就可以了吧，于是下午就去了浙大紫金港校医院，可能是因为周末的缘故，里面人不多，医生也不多，很多科室都是没人的，只有值班的在急诊室，于是挂号去看病，(之前在深圳工作的时候看病只需要一个医保卡就可以了，在杭州也办理了市民卡，也就是医保卡，没想到试用的时候还需要病历本，于是医保就没用成)，到了急诊室，医生问了一点情况，让先量个体温，38.7度，医生说怎么温度这么高，让去化验血，于是就去化验血(其实这些套路，我都清楚，上大学的时候发烧到校医院也是会让去验血)，验血说超敏高出十多倍，于是让输液，我想着输完液应该就没事了吧，我本身也就是要来输液的，因为之前每次发烧都是会输液的。医生还给开了两片退烧药，并告知明天要来复查一下血，我心想难道一天就可以输好吗，以前每次发烧去看病，医生都会让输两天液，输完液出来天已经黑了，但是我并没有觉得有什么好转，心里还想着可能没那么快，夜里回去睡个觉就好了，但是夜里回去依然很难受，依然高烧，吃了一片退烧药还是高烧接近39度，整夜睡不着，心想明天肯定是上不了班了，还是要输液。<br><a id="more"></a></p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>11月30号，周一，早上依然发烧，咳嗽也有加重的倾向，又吃了一片退烧药之后我就打车去了浙大校医院，周一里面各科室的医生都上班了，这次我挂完号来到二楼内科，然后简单说了一下情况，医生说一天病毒肯定没有降下去，今天不用验血了，听说我持续发高烧不退，怀疑我是肺炎，让去拍个胸片，结果出来之后，医生看了看说好像也没什么，说昨天医生给我开的抗病毒的药换掉，今天再输一天，明天再来复查血，输完液之后，也没什么胃口，就直接回家了，心想着看来段时间内病可能不会好了，我要去领一下病历本，不然每次自费也挺贵的，于是问了老板到哪里可以领病历本，老板一会就把地址发过来了，还好很近，一个起步价，我领完回来就睡了，但是感觉并没有什么好转，夜里睡觉的时候温度已经超过39度了，整夜又是熬过去的。</p><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>12月1号，周二，早上睡完觉之后，中午随便吃了点东西然后就又去浙大紫金港校医院，我还是去看的同一个医生，告诉医生我昨天夜里回去还是发烧都已经发烧到39度多了，医生先让我去复查了一下血，超敏那一项不但没降反而还升高了，医生又让我拍个胸片，我没多想就去拍了，结果还是没事，我给医生看片子的时候，我说要不要拿出昨天的片子对比一下，医生才意识到昨天让我拍过，居然向我说对不起，说忘记了，让我又多拍了一次片子，我说没事，我心想可能今天病情加重了，再拍一次也很正常啊，只要能够找到病因就好啊，医生还是很愧疚，还去向内科主任检讨了一下，弄的我还挺不好意思的。</p><p>拍片显示没什么问题，医生说还是只能当做支气管炎来治，然后说昨天用的药都没问题，今天把头孢换成进口的，然后开两天的药，输完两天再看看，因为我咳嗽加重，我让医生顺便给我开点咳嗽药，医生开了强力枇杷露，输完液吃点东西就回去了，夜里喝完药之后还是发烧，而且咳嗽严重，我想着不行了，如果明天的输完再没有好转，我要去大医院了。</p><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><p>12月2号，周三，我上午睡了一会，然后起床继续去输液，去输液之前我去又问了一下医生，我说我昨夜回去依然高烧，医生感觉也很无能为力了，建议我去大医院，说附近的同德医院也不远，建议我去那边看，之前老板推荐我去绿城医院，我就问医生绿城医院怎样，医生说绿城医院是专科医院，呼吸道问题还是同德好一些，我说好，等今天输完液再不退烧，我就去大医院，然而输完液回去，夜里依然发烧，而且整夜咳嗽，难受的不行，我想着明天必须去大医院了，拖延症晚期。。</p><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><p>12月3号，周四，我决定还是听老板的建议去绿城医院，十点多去的，和医生说明了情况，并拿出之前校医院拍的胸片和所使用的药，绿城医院的医生建议我拍个胸部CT看的清楚一些，我想先验血看看超敏指标降下来没有，验血结果依然很高，医生说你这个指标已经很高了，让我去拍CT，拍完CT告知要两个小时才能拿到结果，于是就在医院等，中间出去买了一个包子也没有吃完，这个时候已经感觉咳嗽的时候，背部都开始疼了。</p><p>下午1点半上班，医院上班了，我就去拿我的CT片子和结果，三张片子，然后我看到诊断结果那张纸下面的映像诊断下写着：两肺多节段炎症，建议治疗后复查，我心想结果可能不太好，我拿着片子去找医生，医生看了之后说肺炎啊，然后对着片子看，说你这肺炎已经很严重了啊，需要住院啊，当时我内心挺不好受的，然后医生就打电话问内科住院部还有床位不，结果是没有了，医生又打电话问急诊室，急诊室说还有一张床位，然后就安排我过去了，我问要多久医生说你这情况比较严重7到10天吧，办好住院手续之后，我和急诊室的护士说我要回去拿点生活用品，然后护士说好，说最好洗个澡，因为急诊室病房没法洗澡，然后我回去洗洗澡，带着必须生活用品就去医院了。</p><p>进去之后就开始输液做雾化了，然后还有一个医生过来说我这种情况比较严重，至少要10天以上，当时我心里是很难接受这个结果的，但是也没任何办法，住院的第一夜还是发烧很难受，夜里睡不着，护士告诉我第二天有很多检查，让我早上先不要吃东西。</p><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><p>12月4号，周五，早上五点多左右，护士已经过来给我抽血，抽了很多管血，然后给了我几个单子，让我去等到8点的时候开始去检查，里面有心脏超声波，B超，心电图，我心想为什么我确诊肺炎了，还要做心脏这些检查呢，检查完之后吃个包子就又回去输液了，还好下午护士来告知内科住院部已经有空床了，问我上去不，我心想肯定上去啊，就说好，然后急诊部的护士就带着我去了内科8楼住院部，交接了一下情况，我被安排在一个四人间里面，还好空间很大。</p><h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><p>12月5号，周六，我已经不怎么发高烧了，维持在37.5度一下，每天的治疗就是三次输液，早上8点一次，下午三点一次，夜里11点一次，三次雾化，三次口服药</p><h2 id="第N天"><a href="#第N天" class="headerlink" title="第N天"></a>第N天</h2><p>12月12号，周六，住院的第十天，复查CT，我以为可以出院了，因为感觉除了咳嗽，其他都好的差不多了，下午结果出来之后，医生告诉我吸收的不错，但是因为今天我的主管医生没上班，所以今天不能出院，我问医生那我明天主管医生来了我可以出院吗，医生告诉我应该可以，CT结果显示挺好的，心想那就在住一夜吧，反正明天周日。</p><h2 id="第N-1天"><a href="#第N-1天" class="headerlink" title="第N+1天"></a>第N+1天</h2><p>12月13号，周日，早上没输液前我信心满满地就问主管医生今天可以出院吗，结果主管医生说你看片子，还是有一快很明显的地方没有吸收，今天不能出院，建议我再住3-4天问我能坚持吗，我心里一凉，坚持说我想今天出院，给我开点药，我今天下午输完液出去，医生看我坚持也同意了，不过告诉我这样风险比较大，一旦我又发烧，或者出汗，以及咳嗽加重一定要及时来医院，到病房输液的时候我心里很忐忑，想早点回去工作，却又担心万一病情反复加重怎么办，纠结了很久我心想还是再住一天，我周一下午输完液再走吧，于是我就去告诉医生，我今天不走，等周一下午输完液再走，医生也同意了。</p><h2 id="第N-2天"><a href="#第N-2天" class="headerlink" title="第N+2天"></a>第N+2天</h2><p>12月14号，周一，今天我感觉还是不太好，早上医生查房的时候问我今天出院，下午的液还输不输，我说输完吧，然后医生说那就下午输完液出院，我又问医生，我这样出院没吸收那块炎症是好的可能性大还是严重的可能性大，医生说好的可能性大，但是我还是不放心，因为咳嗽依然很多，我就说我还是再住一夜，明天上午输完液再走吧，医生笑笑说好。</p><h2 id="第N-3天"><a href="#第N-3天" class="headerlink" title="第N+3天"></a>第N+3天</h2><p>12月15号，周二，今天感觉比昨天好多了，上午输完液之后已经10点了，我决定就今天出院，办完出院手续拿好药之后就回来了</p><p>坦白讲出院的感觉真好，回来收拾收拾，然后换换衣服洗洗头就去公司了，到公司就11点半了，好久没有工作了，感觉打字都很别扭，但是工作的感觉真是好，摸着电脑写代码的感觉真是好，健康真好</p><p>还好我在浙大校医院没有耽误太久，还好我去了大医院，还好我去了绿城医院，听病房里面其他人说同德医院病房很脏，还没床位，而且服务态度也很差</p><p>住院这半个月，我是打心底感谢绿城医院的医生和护士，尤其是护士，她们实在是太辛苦，走的时候填反馈表的时候，因为留的空间太小，不然我真的要好好的表扬一下每个护士，这次住院，一来意识到健康的重要性，二来就是真的打心底尊敬护士，她们才是最累，最辛苦的人，但是却一直笑脸相迎</p><p>最后，祝每一个人身体健康，同时也祝每一位护士工作顺利</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一天&quot;&gt;&lt;a href=&quot;#第一天&quot; class=&quot;headerlink&quot; title=&quot;第一天&quot;&gt;&lt;/a&gt;第一天&lt;/h2&gt;&lt;p&gt;11月27号，周五，上班的时候感觉要有点感冒，心想昨夜打球可能着凉了，想着多喝点开水，也许就不会感冒了！&lt;/p&gt;
&lt;h2 id=&quot;第二天&quot;&gt;&lt;a href=&quot;#第二天&quot; class=&quot;headerlink&quot; title=&quot;第二天&quot;&gt;&lt;/a&gt;第二天&lt;/h2&gt;&lt;p&gt;11月28号，周六，在家睡觉不想起，感觉浑身很冷，想着可能有点发烧，拿出体温计量了一下38度多，难受了一整天，到夜里都接近39度了，喝了点感冒退烧药就睡去了，心想明天还发烧一定要去看医生。&lt;/p&gt;
&lt;h2 id=&quot;第三天&quot;&gt;&lt;a href=&quot;#第三天&quot; class=&quot;headerlink&quot; title=&quot;第三天&quot;&gt;&lt;/a&gt;第三天&lt;/h2&gt;&lt;p&gt;11月29号，周日，依然发烧，并且开始咳嗽，因为四月份刚来杭州，这是来杭州第一次生病，也不知道附近哪里有看病的地方，想着一个感冒发烧也用不着去大医院吧，手机搜索了一下，附近不远有浙江大学紫金港校区医院，心想校医院就可以了吧，于是下午就去了浙大紫金港校医院，可能是因为周末的缘故，里面人不多，医生也不多，很多科室都是没人的，只有值班的在急诊室，于是挂号去看病，(之前在深圳工作的时候看病只需要一个医保卡就可以了，在杭州也办理了市民卡，也就是医保卡，没想到试用的时候还需要病历本，于是医保就没用成)，到了急诊室，医生问了一点情况，让先量个体温，38.7度，医生说怎么温度这么高，让去化验血，于是就去化验血(其实这些套路，我都清楚，上大学的时候发烧到校医院也是会让去验血)，验血说超敏高出十多倍，于是让输液，我想着输完液应该就没事了吧，我本身也就是要来输液的，因为之前每次发烧都是会输液的。医生还给开了两片退烧药，并告知明天要来复查一下血，我心想难道一天就可以输好吗，以前每次发烧去看病，医生都会让输两天液，输完液出来天已经黑了，但是我并没有觉得有什么好转，心里还想着可能没那么快，夜里回去睡个觉就好了，但是夜里回去依然很难受，依然高烧，吃了一片退烧药还是高烧接近39度，整夜睡不着，心想明天肯定是上不了班了，还是要输液。&lt;br&gt;
    
    </summary>
    
      <category term="Twitter" scheme="http://picksomething.cn/categories/Twitter/"/>
    
    
  </entry>
  
  <entry>
    <title>RecyclerView with header and footer</title>
    <link href="http://picksomething.cn/2015/11/06/RecyclerView%20with%20header%20and%20footer/"/>
    <id>http://picksomething.cn/2015/11/06/RecyclerView with header and footer/</id>
    <published>2015-11-06T02:10:10.000Z</published>
    <updated>2018-04-26T02:00:02.468Z</updated>
    
    <content type="html"><![CDATA[<p>最近在实现图1这个设置页面的时候，第一眼看到设计稿的时候只是想着普通的LinearLayout加一些常见的ui控件就足够了，但是细想一下觉得这样布局里面重复的代码太多，而且后面要是再多添加几项设置或者删除某项设置，改动也挺大的，想着用RecyclerView带上header合footer实现起来更加合理，于是就使用RecyclerView实现了。</p><p><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/11/QQ20151106-0.png"></p><p>在用带header和footer的RecyclerView实现之前必须先确定好header和footer的布局，我是这样分类header和footer的，见图：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/11/QQ20151106-1.png"></p><p>之所以把记录提醒也算到header里面而不是普通的一个item里面是因为记录提醒这个设置项点击开启之后，会在其下方出来一个提示时间的显示和修改的布局，当然这并不是说不能把记录提醒当做一个item处理，完全可以的，我只是偷点懒而已</p><p>那么选择好header和footer之后，接下来就是编程实现了，这里主要是适配器的代码来控制header，item和footer，所以只贴出适配器的代码，其他在activity为RecyclerView设置LayoutManager和适配器这部分代码都很简单了，适配器代码如下，部分地方已标注：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_HEADER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_ITEM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_FOODER = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> List mList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SettingAdapter</span><span class="params">(Context context, List list)</span> </span>&#123;</span><br><span class="line">        L.d(<span class="string">"SettingAdapter Construction list size = "</span> + list.size());</span><br><span class="line">        mContext = context;</span><br><span class="line">        mList = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (viewType == TYPE_ITEM) &#123;</span><br><span class="line">            View item = LayoutInflater.from(mContext)</span><br><span class="line">                    .inflate(R.layout.layout_settings_item, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SettingItemVH(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_HEADER) &#123;</span><br><span class="line">            View header = LayoutInflater.from(mContext)</span><br><span class="line">                    .inflate(R.layout.layout_settings_header, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SettingHeaderVH(header);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_FOODER) &#123;</span><br><span class="line">            View footer = LayoutInflater.from(mContext)</span><br><span class="line">                    .inflate(R.layout.layout_settings_footer, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SettingFooterVH(footer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"there is no type matches the type "</span> + viewType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> SettingItemVH) &#123;</span><br><span class="line">            SettingItem settingItem = getItem(position);</span><br><span class="line"></span><br><span class="line">            ((SettingItemVH) holder).mIcon.setImageResource(settingItem.getIcon());</span><br><span class="line">            ((SettingItemVH) holder).mTitle.setText(settingItem.getTitle());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> SettingHeaderVH) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为多了header和footer这里要+2</span></span><br><span class="line">        <span class="keyword">return</span> mList.size() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据position获取ViewType</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isHeader(position))</span><br><span class="line">            <span class="keyword">return</span> TYPE_HEADER;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFooter(position))</span><br><span class="line">            <span class="keyword">return</span> TYPE_FOODER;</span><br><span class="line">        <span class="keyword">return</span> TYPE_ITEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个item是header</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHeader</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个item是footer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFooter</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position == getItemCount()-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常的item是从1开始的，0是header，所以获取正常item的时候是position-1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SettingItem <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mList.get(position - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SettingItemVH</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ImageView mIcon;</span><br><span class="line">        <span class="keyword">private</span> TextView mTitle;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SettingItemVH</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            mIcon = (ImageView) itemView.findViewById(R.id.setting_item_icon);</span><br><span class="line">            mTitle = (TextView) itemView.findViewById(R.id.setting_item_title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SettingHeaderVH</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SettingHeaderVH</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SettingFooterVH</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SettingFooterVH</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的就是getItem的时候是position-1，因为设置item是从第一个开始的，第0个被header占用了，为了获取传进来的list中的索引为0的设置item，就要用position-1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在实现图1这个设置页面的时候，第一眼看到设计稿的时候只是想着普通的LinearLayout加一些常见的ui控件就足够了，但是细想一下觉得这样布局里面重复的代码太多，而且后面要是再多添加几项设置或者删除某项设置，改动也挺大的，想着用RecyclerView带上header合footer实现起来更加合理，于是就使用RecyclerView实现了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/11/QQ20151106-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在用带header和footer的RecyclerView实现之前必须先确定好header和footer的布局，我是这样分类header和footer的，见图：&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/11/QQ20151106-1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;之所以把记录提醒也算到header里面而不是普通的一个item里面是因为记录提醒这个设置项点击开启之后，会在其下方出来一个提示时间的显示和修改的布局，当然这并不是说不能把记录提醒当做一个item处理，完全可以的，我只是偷点懒而已&lt;/p&gt;
&lt;p&gt;那么选择好header和footer之后，接下来就是编程实现了，这里主要是适配器的代码来控制header，item和footer，所以只贴出适配器的代码，其他在activity为RecyclerView设置LayoutManager和适配器这部分代码都很简单了，适配器代码如下，部分地方已标注：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="footer" scheme="http://picksomething.cn/tags/footer/"/>
    
      <category term="header" scheme="http://picksomething.cn/tags/header/"/>
    
      <category term="RecyclerView" scheme="http://picksomething.cn/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>Android实现涟漪动画</title>
    <link href="http://picksomething.cn/2015/09/28/Android%E5%AE%9E%E7%8E%B0%E6%B6%9F%E6%BC%AA%E5%8A%A8%E7%94%BB/"/>
    <id>http://picksomething.cn/2015/09/28/Android实现涟漪动画/</id>
    <published>2015-09-28T15:16:20.000Z</published>
    <updated>2018-04-25T06:17:59.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>因为开发launcher的桌面启动动画的时候，根据设计师的要求，需要实现一个涟漪的效果，具体效果如下：</p><p><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/09/ezgif.com-crop.gif"></p><p>然后动画的具体细节要求是这样的：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/09/QQ20150928-2@2x.png"><br><a id="more"></a></p><p>我Google搜索了一下涟漪效果，发现Github上有一些类似的开源库，但是发现大部分都是点击按钮然后开始出现涟漪效果，与自己要做的这个涟漪动画不太符合，所以在dwl的启发下，想着干脆自己实现一个算了，于是就尝试着自定义这个涟漪动画，最终实现的效果就和上面的是一样的，下面阐述一下实现原理</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先我们将这个动画看成是一个圆环，圆环里面的小圆是一个空心的透明圆，外面是一个透明的大圆，draw圆环的原理很简单，就是在draw透明圆的基础上，将画笔paint的strokeWidth设置成外面的环的宽度</p><blockquote><p>这里需要注意的是，事实上通过设置strokeWidth之后draw出来的外面大圆的半径并不是简单的内圆的半径加上圆环的宽度，而是内圆的半径+1/2圆环的宽度</p></blockquote><p>如下图所示，红色的就是半径就是我们在draw圆环外面大圆的时候应该设置的半径，然后将笔宽strokeWidth设置为圆环的宽度即可：<br><img src="http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/09/QQ20150928-3@2x.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那么知道draw圆环的原理之后，下面就可以开始draw了，里面的小圆很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawCircle(centerX, centerY, mCircleRadius, mCirclePaint);</span><br></pre></td></tr></table></figure></p><p>外面的大圆：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawCircle(centerX, centerY, mCircleRadius + mRippleWidth / <span class="number">2</span>, mRipplePaint);</span><br></pre></td></tr></table></figure></p><blockquote><p>重点就是mRippleWidth这个变量，根据动画介绍可以，波纹的宽度是从0到mRippleWidth，那么根据上面我们说的外圆的半径为内圆的半径+1/2(圆环)波纹的宽度，所以大圆的半径是mCircleRadius+mRippleWidth/2</p></blockquote><p>半径的变化规律知道了，只有半径的变化显然是不够的，为了达到波纹从0到mRippleWidth的效果，我们必须同步更改大圆画笔paint的strokeWidth的值，也就是画出圆环效果，strokeWidth的变化规律和波纹宽度是一样的，从0到mRippleWidth。ok，知道了半径和大圆画笔的变化规律，接下来就是按照规律去改变对应的值，然后刷新界面了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator va = ValueAnimator.ofInt(<span class="number">0</span>, sRippleWidth);</span><br><span class="line">va.setDuration(RIPPLE_ANIM_DURATION * <span class="number">2</span>);</span><br><span class="line">va.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">        mRippleWidth = value;</span><br><span class="line">        mRipplePaint.setStrokeWidth(value);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">va.start();</span><br></pre></td></tr></table></figure><p>在初始化代码片段中，我们将外面的大圆画笔paint的strokeWidth初始化为0，颜色初始化成波纹的颜色：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mRipplePaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">mRipplePaint.setStrokeWidth(<span class="number">0</span>);</span><br><span class="line">mRipplePaint.setARGB(<span class="number">127</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure></p><p>然后根据动画的定义，我们逐渐地将画笔的宽度设置为从0到最终波纹宽度的每一个临时宽度，同时也将波纹变化过程中的的每一个临时宽度值赋值给mRippleWidth用来更新大圆的半径。然后调用invalidata()刷新界面，这样效果就出来了</p><p>当然还有一些细节，比如波纹宽度渐变的过程中，要伴随着alpha变化，同时要求波纹到指定时间后自动开始(这里是3000毫秒开始)，都需要我们去实现，但这些不是主要难点了，相信大家都能搞定</p><p>就这样了，欢迎大家交流意见</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;因为开发launcher的桌面启动动画的时候，根据设计师的要求，需要实现一个涟漪的效果，具体效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/09/ezgif.com-crop.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后动画的具体细节要求是这样的：&lt;br&gt;&lt;img src=&quot;http://p7ohyql3p.bkt.clouddn.com/static/images/uploads/2015/09/QQ20150928-2@2x.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://picksomething.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://picksomething.cn/tags/Android/"/>
    
      <category term="Ripple" scheme="http://picksomething.cn/tags/Ripple/"/>
    
      <category term="涟漪动画" scheme="http://picksomething.cn/tags/%E6%B6%9F%E6%BC%AA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>来杭半年</title>
    <link href="http://picksomething.cn/2015/09/27/%E6%9D%A5%E6%9D%AD%E5%8D%8A%E5%B9%B4/"/>
    <id>http://picksomething.cn/2015/09/27/来杭半年/</id>
    <published>2015-09-26T17:53:56.000Z</published>
    <updated>2018-04-25T15:02:11.854Z</updated>
    
    <content type="html"><![CDATA[<p>时间总是过的挺快，转眼间离上次写这篇博客(<a href="http://picksomething.cn/2015/04/26/%E6%9D%A5%E6%9D%AD%E4%B8%80%E4%B8%AA%E6%9C%88/">来杭一个月</a>)已经又过去了五个月，我来杭州也半年了</p><p>六个月，说长也长，说不长也不长，但是多多少少都会有一些心里上的变化，也就是人们常说的所谓成长吧。</p><p>作为一名程序员，我不擅长煽情，也不喜欢煽情，只是想简单的记录一下自己生活和心理上的变化，留着以后回头观望<br><a id="more"></a></p><h2 id="工作："><a href="#工作：" class="headerlink" title="工作："></a>工作：</h2><p>来杭半年，也即是在新公司工作半年了，在小公司很多事情你都要靠自己，我也喜欢这种不断挑战自己，提升自己的感觉，目前对于自己负责业务也都很熟悉了，做起来也很得心应手，当然也还是多亏dwl的帮助和支持，深表感谢。</p><p>自己在新公司主要负责移动广告业务和小工具开发，现在偶尔也会协助dwl做一些launcher相关的开发，他一个人开发launcher的确太辛苦，而且我们公司也只有我们两个Android开发，所以只能找我帮忙了，虽然我很菜。另外打个广告，小工具目前已经开发两个了，分别是<a href="http://www.wandoujia.com/apps/com.huhulab.apkmanager" target="_blank" rel="noopener">安装包管理</a>和<a href="http://www.wandoujia.com/apps/com.huhulab.efficiencycleanup" target="_blank" rel="noopener">效率解锁清理</a>，反应大家到Android各大应用市场下载反馈</p><p>技术上这半年通过自己的努力和实践以及dwl的帮助，感觉在Android开发上有了很大的提升，和之前在深圳相比，简直是质的提升，以前遇到不会的问题，就不想去弄，觉得自己肯定解决不了，现在不一样了，现在无论设计师给什么样的设计，老板给什么样的需求，都会尽力的去做好，觉得只要细细分析，慢慢实践就一定能够搞的定。果然创业公司锻炼人，而且还是和dwl大神一起工作，这货一个人负责桌面开发，硬是一个人把我们公司的重量级产品开发出来了，而且做的还不错哦</p><h2 id="生活："><a href="#生活：" class="headerlink" title="生活："></a>生活：</h2><p>半年时间，只要你愿意，肯定能够对一个城市了解很多，熟悉很多。不过，我还是比较宅，周末也懒得出去，都是在我们小区和城西银泰附近消遣或者干脆在家睡懒觉</p><h3 id="吃："><a href="#吃：" class="headerlink" title="吃："></a>吃：</h3><p>算是我和我女朋友最感兴趣的爱好了，每周都会出去吃一次或者两次大餐，城西银泰里面都快吃一个遍了，不过吃的多了，渐渐吃的那几样就固定了，比如我们半年到春暖花开吃自助餐吃了三次了，去吃炉鱼吃过好像6次了，最近这几周几乎每周都去吃，不过我觉得也挺好吃的。想其他外婆家啊，第二乐章啊，新石器烤肉啊，望湘园啊，小火锅啊也都挺好吃的。在吃上也花了不少钱。。。</p><h3 id="住："><a href="#住：" class="headerlink" title="住："></a>住：</h3><p>之前说打算换房子，不过到现在还是没有换，因为我和我女朋友都是那种一旦熟悉一个地方，就懒得挪窝的人。看到我们女朋友上班还要转公交车，我很多次都说我们换个离你公司近一点的房子吧，但是她说不想换，已经对这熟悉了，觉得也挺好。所以一直都没换成，不过我觉得终究还是要换的，毕竟一是离我女朋友公司太远，二是不带个厨房着实不方便，很多时候想自己做个饭也挺麻烦的</p><h3 id="玩："><a href="#玩：" class="headerlink" title="玩："></a>玩：</h3><p>也没什么玩的，顶多就是遇到好看的电影去看看电影，很多次我给我女朋友说周末带她去千岛湖，横店，乌镇，宋城等地方玩，她都说太累不想出去，所以来杭半年了，这些地方都还没去过。。。</p><p>好了，工作和生活也就是这样，感觉上的变化，就是觉得渐渐地融入杭州这座城市了，喜欢上这座城市了，感觉杭州挺美的，文明礼让，也都挺友好的</p><p>不足也要说一下，就是拖延症好像越来越严重了，说的认真的学习python，ios开发，然后没学两天就放那里了，想起来了又去学两天，这样是很不对的，一定要连续的学习，不断地学习，才能不被淘汰</p><p>继续努力，完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间总是过的挺快，转眼间离上次写这篇博客(&lt;a href=&quot;http://picksomething.cn/2015/04/26/%E6%9D%A5%E6%9D%AD%E4%B8%80%E4%B8%AA%E6%9C%88/&quot;&gt;来杭一个月&lt;/a&gt;)已经又过去了五个月，我来杭州也半年了&lt;/p&gt;
&lt;p&gt;六个月，说长也长，说不长也不长，但是多多少少都会有一些心里上的变化，也就是人们常说的所谓成长吧。&lt;/p&gt;
&lt;p&gt;作为一名程序员，我不擅长煽情，也不喜欢煽情，只是想简单的记录一下自己生活和心理上的变化，留着以后回头观望&lt;br&gt;
    
    </summary>
    
      <category term="Twitter" scheme="http://picksomething.cn/categories/Twitter/"/>
    
    
      <category term="杭州" scheme="http://picksomething.cn/tags/%E6%9D%AD%E5%B7%9E/"/>
    
      <category term="半年" scheme="http://picksomething.cn/tags/%E5%8D%8A%E5%B9%B4/"/>
    
  </entry>
  
</feed>
